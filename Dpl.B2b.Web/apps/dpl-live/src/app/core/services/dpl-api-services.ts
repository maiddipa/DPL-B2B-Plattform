/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.5.0.0 (NJsonSchema v10.1.15.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class AccountingRecordsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		refLtmsAccountId?: number | undefined,
		refLtmsArticleId?: number | undefined,
		status?: AccountingRecordStatus | null | undefined,
	}): Observable<LoadResult> {
        let url_ = this.baseUrl + "/accountingrecords?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.refLtmsAccountId === null)
            throw new Error("The parameter 'refLtmsAccountId' cannot be null.");
        else if (request.refLtmsAccountId !== undefined)
            url_ += "RefLtmsAccountId=" + encodeURIComponent("" + request.refLtmsAccountId) + "&";
        if (request.refLtmsArticleId === null)
            throw new Error("The parameter 'refLtmsArticleId' cannot be null.");
        else if (request.refLtmsArticleId !== undefined)
            url_ += "RefLtmsArticleId=" + encodeURIComponent("" + request.refLtmsArticleId) + "&";
        if (request.status !== undefined && request.status !== null)
            url_ += "Status=" + encodeURIComponent("" + request.status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadResult>(<any>null);
    }

    getById(id: number): Observable<AccountingRecord> {
        let url_ = this.baseUrl + "/accountingrecords/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AccountingRecord>><any>_observableThrow(e);
                }
            } else
                return <Observable<AccountingRecord>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AccountingRecord> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AccountingRecord>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class AddressesAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getCountries(): Observable<Country[]> {
        let url_ = this.baseUrl + "/addressesadministration/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<Country[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Country[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Country[]>(<any>null);
    }

    getStatesByCountryId(id: number): Observable<CountryState[]> {
        let url_ = this.baseUrl + "/addressesadministration/{id}/states";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStatesByCountryId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStatesByCountryId(<any>response_);
                } catch (e) {
                    return <Observable<CountryState[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountryState[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetStatesByCountryId(response: HttpResponseBase): Observable<CountryState[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CountryState[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		id?: number | null | undefined,
		street1?: string | null | undefined,
		street2?: string | null | undefined,
		postalCode?: string | null | undefined,
		city?: string | null | undefined,
		stateName?: string | null | undefined,
		countryName?: string | null | undefined,
	}): Observable<LoadResult> {
        let url_ = this.baseUrl + "/addressesadministration?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.id !== undefined && request.id !== null)
            url_ += "Id=" + encodeURIComponent("" + request.id) + "&";
        if (request.street1 !== undefined && request.street1 !== null)
            url_ += "Street1=" + encodeURIComponent("" + request.street1) + "&";
        if (request.street2 !== undefined && request.street2 !== null)
            url_ += "Street2=" + encodeURIComponent("" + request.street2) + "&";
        if (request.postalCode !== undefined && request.postalCode !== null)
            url_ += "PostalCode=" + encodeURIComponent("" + request.postalCode) + "&";
        if (request.city !== undefined && request.city !== null)
            url_ += "City=" + encodeURIComponent("" + request.city) + "&";
        if (request.stateName !== undefined && request.stateName !== null)
            url_ += "StateName=" + encodeURIComponent("" + request.stateName) + "&";
        if (request.countryName !== undefined && request.countryName !== null)
            url_ += "CountryName=" + encodeURIComponent("" + request.countryName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadResult>(<any>null);
    }

    post(values?: string | null | undefined): Observable<AddressAdministration> {
        let url_ = this.baseUrl + "/addressesadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<AddressAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<AddressAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <AddressAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(key?: number | undefined, values?: string | null | undefined): Observable<AddressAdministration> {
        let url_ = this.baseUrl + "/addressesadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (key === null || key === undefined)
            throw new Error("The parameter 'key' cannot be null.");
        else
            content_.append("key", key.toString());
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<AddressAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<AddressAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AddressAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressAdministration>(<any>null);
    }

    getById(id: number): Observable<AddressAdministration> {
        let url_ = this.baseUrl + "/addressesadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<AddressAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<AddressAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AddressAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class BalanceTransfersApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param status (optional) 
     * @param sourceAccountId (optional) 
     * @param destinationAccountId (optional) 
     * @param loadCarrierId (optional) 
     * @param quantity (optional) 
     * @param note (optional) 
     * @deprecated
     */
    get(request: {
		status?: BalanceTransferStatus | undefined,
		sourceAccountId?: number | undefined,
		destinationAccountId?: number | undefined,
		loadCarrierId?: number | undefined,
		quantity?: number | undefined,
		note?: string | null | undefined,
	}): Observable<IPaginationResultOfBalanceTransfer> {
        let url_ = this.baseUrl + "/balancetransfers?";
        if (request.status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (request.status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + request.status) + "&";
        if (request.sourceAccountId === null)
            throw new Error("The parameter 'sourceAccountId' cannot be null.");
        else if (request.sourceAccountId !== undefined)
            url_ += "SourceAccountId=" + encodeURIComponent("" + request.sourceAccountId) + "&";
        if (request.destinationAccountId === null)
            throw new Error("The parameter 'destinationAccountId' cannot be null.");
        else if (request.destinationAccountId !== undefined)
            url_ += "DestinationAccountId=" + encodeURIComponent("" + request.destinationAccountId) + "&";
        if (request.loadCarrierId === null)
            throw new Error("The parameter 'loadCarrierId' cannot be null.");
        else if (request.loadCarrierId !== undefined)
            url_ += "LoadCarrierId=" + encodeURIComponent("" + request.loadCarrierId) + "&";
        if (request.quantity === null)
            throw new Error("The parameter 'quantity' cannot be null.");
        else if (request.quantity !== undefined)
            url_ += "Quantity=" + encodeURIComponent("" + request.quantity) + "&";
        if (request.note !== undefined && request.note !== null)
            url_ += "Note=" + encodeURIComponent("" + request.note) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfBalanceTransfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfBalanceTransfer>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IPaginationResultOfBalanceTransfer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfBalanceTransfer>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfBalanceTransfer>(<any>null);
    }

    post(request: BalanceTransferCreateRequest): Observable<PostingRequest> {
        let url_ = this.baseUrl + "/balancetransfers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<PostingRequest>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingRequest>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<PostingRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <PostingRequest>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    getById(id: number): Observable<BalanceTransfer> {
        let url_ = this.baseUrl + "/balancetransfers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<BalanceTransfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<BalanceTransfer>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<BalanceTransfer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BalanceTransfer>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    post2(id: number, request: BalanceTransferCancelRequest): Observable<BalanceTransfer> {
        let url_ = this.baseUrl + "/balancetransfers/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost2(<any>response_);
                } catch (e) {
                    return <Observable<BalanceTransfer>><any>_observableThrow(e);
                }
            } else
                return <Observable<BalanceTransfer>><any>_observableThrow(response_);
        }));
    }

    protected processPost2(response: HttpResponseBase): Observable<BalanceTransfer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BalanceTransfer>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalanceTransfer>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ChatUsersApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		emails?: string[] | null | undefined,
	}): Observable<ChatUser[]> {
        let url_ = this.baseUrl + "/chatusers?";
        if (request.emails !== undefined && request.emails !== null)
            request.emails && request.emails.forEach(item => { url_ += "Emails=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ChatUser[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ChatUser[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ChatUser[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ChatUser[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ChatUser[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CountriesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<Country[]> {
        let url_ = this.baseUrl + "/countries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Country[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Country[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Country[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Country[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Country[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomerDivisionsAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getById(id: number): Observable<CustomerDivision> {
        let url_ = this.baseUrl + "/customerdivisionsadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDivision>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDivision>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CustomerDivision> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerDivision>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    delete(id: number): Observable<CustomerDivision> {
        let url_ = this.baseUrl + "/customerdivisionsadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDivision>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDivision>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<CustomerDivision> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerDivision>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(): Observable<CustomerDivision[]> {
        let url_ = this.baseUrl + "/customerdivisionsadministration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDivision[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDivision[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CustomerDivision[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerDivision[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDivision[]>(<any>null);
    }

    post(request: CustomerDivisionCreateRequest): Observable<CustomerDivision> {
        let url_ = this.baseUrl + "/customerdivisionsadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDivision>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDivision>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<CustomerDivision> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <CustomerDivision>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patch(request: CustomerDivisionUpdateRequest): Observable<CustomerDivision> {
        let url_ = this.baseUrl + "/customerdivisionsadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDivision>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDivision>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<CustomerDivision> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerDivision>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDivision>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomerDocumentSettingsAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		customerId?: number | null | undefined,
	}): Observable<LoadResult> {
        let url_ = this.baseUrl + "/customer-document-settings?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.customerId !== undefined && request.customerId !== null)
            url_ += "CustomerId=" + encodeURIComponent("" + request.customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadResult>(<any>null);
    }

    post(values?: string | null | undefined): Observable<CustomerDocumentSettings> {
        let url_ = this.baseUrl + "/customer-document-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDocumentSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDocumentSettings>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<CustomerDocumentSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <CustomerDocumentSettings>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(key?: number | undefined, values?: string | null | undefined): Observable<CustomerDocumentSettings> {
        let url_ = this.baseUrl + "/customer-document-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (key === null || key === undefined)
            throw new Error("The parameter 'key' cannot be null.");
        else
            content_.append("key", key.toString());
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDocumentSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDocumentSettings>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<CustomerDocumentSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerDocumentSettings>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDocumentSettings>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomersAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getById(id: number): Observable<Customer> {
        let url_ = this.baseUrl + "/customersadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<Customer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Customer>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Customer>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    delete(id: number): Observable<Customer> {
        let url_ = this.baseUrl + "/customersadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<Customer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Customer>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Customer>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(): Observable<Customer[]> {
        let url_ = this.baseUrl + "/customersadministration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Customer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Customer[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Customer[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Customer[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Customer[]>(<any>null);
    }

    post(request: CustomerCreateRequest): Observable<Customer> {
        let url_ = this.baseUrl + "/customersadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<Customer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Customer>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Customer>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patch(request: CustomerUpdateRequest): Observable<Customer> {
        let url_ = this.baseUrl + "/customersadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<Customer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Customer>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Customer>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Customer>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class CustomersApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<Customer[]> {
        let url_ = this.baseUrl + "/customers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Customer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Customer[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Customer[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Customer[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Customer[]>(<any>null);
    }

    post(request: CustomerCreateRequest): Observable<Customer> {
        let url_ = this.baseUrl + "/customers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<Customer>><any>_observableThrow(e);
                }
            } else
                return <Observable<Customer>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<Customer> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Customer>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class DivisionDocumentSettingsAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getDocumentTypes(): Observable<DocumentType[]> {
        let url_ = this.baseUrl + "/division-document-settings/document-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentTypes(<any>response_);
                } catch (e) {
                    return <Observable<DocumentType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentTypes(response: HttpResponseBase): Observable<DocumentType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentType[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentType[]>(<any>null);
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		customerDivisionId?: number | null | undefined,
	}): Observable<LoadResult> {
        let url_ = this.baseUrl + "/division-document-settings?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.customerDivisionId !== undefined && request.customerDivisionId !== null)
            url_ += "CustomerDivisionId=" + encodeURIComponent("" + request.customerDivisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadResult>(<any>null);
    }

    post(values?: string | null | undefined): Observable<CustomerDivisionDocumentSetting> {
        let url_ = this.baseUrl + "/division-document-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDivisionDocumentSetting>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDivisionDocumentSetting>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<CustomerDivisionDocumentSetting> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <CustomerDivisionDocumentSetting>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(key?: number | undefined, values?: string | null | undefined): Observable<CustomerDivisionDocumentSetting> {
        let url_ = this.baseUrl + "/division-document-settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (key === null || key === undefined)
            throw new Error("The parameter 'key' cannot be null.");
        else
            content_.append("key", key.toString());
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDivisionDocumentSetting>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDivisionDocumentSetting>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<CustomerDivisionDocumentSetting> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerDivisionDocumentSetting>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDivisionDocumentSetting>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class DocumentsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<IPaginationResultOfDocument> {
        let url_ = this.baseUrl + "/documents?";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfDocument>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfDocument>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IPaginationResultOfDocument> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfDocument>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfDocument>(<any>null);
    }

    getDocumentDownload(id: number): Observable<string> {
        let url_ = this.baseUrl + "/documents/{id}/download-link";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentDownload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentDownload(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentDownload(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class DocumentSettingsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<DocumentSettings> {
        let url_ = this.baseUrl + "/document-settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DocumentSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DocumentSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentSettings>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentSettings>(<any>null);
    }

    patchCustomerDocumentSettings(id: number, request: CustomerDocumentSettingsUpdateRequest): Observable<CustomerDocumentSettings> {
        let url_ = this.baseUrl + "/document-settings/customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchCustomerDocumentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchCustomerDocumentSettings(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDocumentSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDocumentSettings>><any>_observableThrow(response_);
        }));
    }

    protected processPatchCustomerDocumentSettings(response: HttpResponseBase): Observable<CustomerDocumentSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerDocumentSettings>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patchDivisionCustomerDocumentSettings(id: number, request: CustomerDivisionDocumentSettingsUpdateRequest): Observable<CustomerDivisionDocumentSettings> {
        let url_ = this.baseUrl + "/document-settings/division/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchDivisionCustomerDocumentSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchDivisionCustomerDocumentSettings(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDivisionDocumentSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDivisionDocumentSettings>><any>_observableThrow(response_);
        }));
    }

    protected processPatchDivisionCustomerDocumentSettings(response: HttpResponseBase): Observable<CustomerDivisionDocumentSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerDivisionDocumentSettings>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class DplEmployeeApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    searchCustomers(request: {
		searchTerm?: string | null | undefined,
	}): Observable<DplEmployeeCustomer[]> {
        let url_ = this.baseUrl + "/dpl-employee?";
        if (request.searchTerm !== undefined && request.searchTerm !== null)
            url_ += "searchTerm=" + encodeURIComponent("" + request.searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchCustomers(<any>response_);
                } catch (e) {
                    return <Observable<DplEmployeeCustomer[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DplEmployeeCustomer[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchCustomers(response: HttpResponseBase): Observable<DplEmployeeCustomer[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DplEmployeeCustomer[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DplEmployeeCustomer[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ErrorApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    error(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/error";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processError(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processError(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processError(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ExpressCodesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		issuingPostingAccountId?: number | null | undefined,
		issuingCustomerDivisionId?: number | undefined,
		printType?: PrintType | null | undefined,
		issuingDivisionName?: string | null | undefined,
		expressCode?: string | null | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<IPaginationResultOfExpressCode> {
        let url_ = this.baseUrl + "/expresscodes?";
        if (request.issuingPostingAccountId !== undefined && request.issuingPostingAccountId !== null)
            url_ += "IssuingPostingAccountId=" + encodeURIComponent("" + request.issuingPostingAccountId) + "&";
        if (request.issuingCustomerDivisionId === null)
            throw new Error("The parameter 'issuingCustomerDivisionId' cannot be null.");
        else if (request.issuingCustomerDivisionId !== undefined)
            url_ += "IssuingCustomerDivisionId=" + encodeURIComponent("" + request.issuingCustomerDivisionId) + "&";
        if (request.printType !== undefined && request.printType !== null)
            url_ += "PrintType=" + encodeURIComponent("" + request.printType) + "&";
        if (request.issuingDivisionName !== undefined && request.issuingDivisionName !== null)
            url_ += "IssuingDivisionName=" + encodeURIComponent("" + request.issuingDivisionName) + "&";
        if (request.expressCode !== undefined && request.expressCode !== null)
            url_ += "ExpressCode=" + encodeURIComponent("" + request.expressCode) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfExpressCode>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfExpressCode>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IPaginationResultOfExpressCode> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfExpressCode>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfExpressCode>(<any>null);
    }

    post(request: ExpressCodeCreateRequest): Observable<ExpressCode> {
        let url_ = this.baseUrl + "/expresscodes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<ExpressCode>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpressCode>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<ExpressCode> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <ExpressCode>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getByCode(request: {
		issuingPostingAccountId?: number | null | undefined,
		issuingCustomerDivisionId?: number | undefined,
		printType?: PrintType | null | undefined,
		issuingDivisionName?: string | null | undefined,
		expressCode?: string | null | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<ExpressCode> {
        let url_ = this.baseUrl + "/code-type?";
        if (request.issuingPostingAccountId !== undefined && request.issuingPostingAccountId !== null)
            url_ += "IssuingPostingAccountId=" + encodeURIComponent("" + request.issuingPostingAccountId) + "&";
        if (request.issuingCustomerDivisionId === null)
            throw new Error("The parameter 'issuingCustomerDivisionId' cannot be null.");
        else if (request.issuingCustomerDivisionId !== undefined)
            url_ += "IssuingCustomerDivisionId=" + encodeURIComponent("" + request.issuingCustomerDivisionId) + "&";
        if (request.printType !== undefined && request.printType !== null)
            url_ += "PrintType=" + encodeURIComponent("" + request.printType) + "&";
        if (request.issuingDivisionName !== undefined && request.issuingDivisionName !== null)
            url_ += "IssuingDivisionName=" + encodeURIComponent("" + request.issuingDivisionName) + "&";
        if (request.expressCode !== undefined && request.expressCode !== null)
            url_ += "ExpressCode=" + encodeURIComponent("" + request.expressCode) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCode(<any>response_);
                } catch (e) {
                    return <Observable<ExpressCode>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpressCode>><any>_observableThrow(response_);
        }));
    }

    protected processGetByCode(response: HttpResponseBase): Observable<ExpressCode> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExpressCode>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpressCode>(<any>null);
    }

    patch(id: number, request: ExpressCodeUpdateRequest): Observable<ExpressCode> {
        let url_ = this.baseUrl + "/expresscodes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<ExpressCode>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpressCode>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<ExpressCode> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExpressCode>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patchExpressCodeCancelled(id: number): Observable<ExpressCode> {
        let url_ = this.baseUrl + "/expresscodes/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchExpressCodeCancelled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchExpressCodeCancelled(<any>response_);
                } catch (e) {
                    return <Observable<ExpressCode>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExpressCode>><any>_observableThrow(response_);
        }));
    }

    protected processPatchExpressCodeCancelled(response: HttpResponseBase): Observable<ExpressCode> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExpressCode>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExpressCode>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LoadCarrierReceiptsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		customerDivisionId?: number | undefined,
		documentNumber?: string | null | undefined,
		type?: LoadCarrierReceiptType[] | null | undefined,
		loadCarrierTypes?: number[] | null | undefined,
		issueDateFrom?: Date | null | undefined,
		issueDateTo?: Date | null | undefined,
		isSortingCompleted?: boolean | undefined,
		sortBy?: LoadCarrierReceiptsSearchRequestSortOptions | undefined,
		sortDirection?: ListSortDirection | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<LoadResult> {
        let url_ = this.baseUrl + "/loadcarrierreceipts?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.customerDivisionId === null)
            throw new Error("The parameter 'customerDivisionId' cannot be null.");
        else if (request.customerDivisionId !== undefined)
            url_ += "CustomerDivisionId=" + encodeURIComponent("" + request.customerDivisionId) + "&";
        if (request.documentNumber !== undefined && request.documentNumber !== null)
            url_ += "DocumentNumber=" + encodeURIComponent("" + request.documentNumber) + "&";
        if (request.type !== undefined && request.type !== null)
            request.type && request.type.forEach(item => { url_ += "Type=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierTypes !== undefined && request.loadCarrierTypes !== null)
            request.loadCarrierTypes && request.loadCarrierTypes.forEach(item => { url_ += "LoadCarrierTypes=" + encodeURIComponent("" + item) + "&"; });
        if (request.issueDateFrom !== undefined && request.issueDateFrom !== null)
            url_ += "IssueDateFrom=" + encodeURIComponent(request.issueDateFrom ? "" + request.issueDateFrom.toJSON() : "") + "&";
        if (request.issueDateTo !== undefined && request.issueDateTo !== null)
            url_ += "IssueDateTo=" + encodeURIComponent(request.issueDateTo ? "" + request.issueDateTo.toJSON() : "") + "&";
        if (request.isSortingCompleted === null)
            throw new Error("The parameter 'isSortingCompleted' cannot be null.");
        else if (request.isSortingCompleted !== undefined)
            url_ += "IsSortingCompleted=" + encodeURIComponent("" + request.isSortingCompleted) + "&";
        if (request.sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (request.sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + request.sortBy) + "&";
        if (request.sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (request.sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + request.sortDirection) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadResult>(<any>null);
    }

    post(request: LoadCarrierReceiptsCreateRequest): Observable<LoadCarrierReceipt> {
        let url_ = this.baseUrl + "/loadcarrierreceipts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<LoadCarrierReceipt>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadCarrierReceipt>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<LoadCarrierReceipt> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LoadCarrierReceipt>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    getById(id: number): Observable<LoadCarrierReceipt> {
        let url_ = this.baseUrl + "/loadcarrierreceipts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<LoadCarrierReceipt>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadCarrierReceipt>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LoadCarrierReceipt> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadCarrierReceipt>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getSortingOptionsByReceiptId(id: number): Observable<LoadCarrierReceiptSortingOption> {
        let url_ = this.baseUrl + "/loadcarrierreceipts/{id}/sort-options";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortingOptionsByReceiptId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortingOptionsByReceiptId(<any>response_);
                } catch (e) {
                    return <Observable<LoadCarrierReceiptSortingOption>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadCarrierReceiptSortingOption>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortingOptionsByReceiptId(response: HttpResponseBase): Observable<LoadCarrierReceiptSortingOption> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadCarrierReceiptSortingOption>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patchLoadCarrierReceiptCancel(id: number, request: LoadCarrierReceiptsCancelRequest): Observable<LoadCarrierReceipt> {
        let url_ = this.baseUrl + "/loadcarrierreceipts/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchLoadCarrierReceiptCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchLoadCarrierReceiptCancel(<any>response_);
                } catch (e) {
                    return <Observable<LoadCarrierReceipt>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadCarrierReceipt>><any>_observableThrow(response_);
        }));
    }

    protected processPatchLoadCarrierReceiptCancel(response: HttpResponseBase): Observable<LoadCarrierReceipt> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadCarrierReceipt>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patchLoadCarrierReceiptIsSortingRequired(id: number, request: LoadCarrierReceiptsUpdateIsSortingRequiredRequest): Observable<LoadCarrierReceipt> {
        let url_ = this.baseUrl + "/loadcarrierreceipts/{id}/sortingrequired";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchLoadCarrierReceiptIsSortingRequired(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchLoadCarrierReceiptIsSortingRequired(<any>response_);
                } catch (e) {
                    return <Observable<LoadCarrierReceipt>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadCarrierReceipt>><any>_observableThrow(response_);
        }));
    }

    protected processPatchLoadCarrierReceiptIsSortingRequired(response: HttpResponseBase): Observable<LoadCarrierReceipt> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadCarrierReceipt>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class LoadCarriersApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<LoadCarrier[]> {
        let url_ = this.baseUrl + "/load-carriers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadCarrier[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadCarrier[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadCarrier[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadCarrier[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadCarrier[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LoadCarrierSortingApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    post(request: LoadCarrierSortingCreateRequest): Observable<LoadCarrierSorting> {
        let url_ = this.baseUrl + "/load-carrier-sortings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<LoadCarrierSorting>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadCarrierSorting>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<LoadCarrierSorting> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LoadCarrierSorting>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getByLoadCarrierReceiptId(request: {
		loadCarrierReceiptId?: number | undefined,
	}): Observable<LoadCarrierSorting> {
        let url_ = this.baseUrl + "/load-carrier-sortings?";
        if (request.loadCarrierReceiptId === null)
            throw new Error("The parameter 'loadCarrierReceiptId' cannot be null.");
        else if (request.loadCarrierReceiptId !== undefined)
            url_ += "loadCarrierReceiptId=" + encodeURIComponent("" + request.loadCarrierReceiptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByLoadCarrierReceiptId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByLoadCarrierReceiptId(<any>response_);
                } catch (e) {
                    return <Observable<LoadCarrierSorting>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadCarrierSorting>><any>_observableThrow(response_);
        }));
    }

    protected processGetByLoadCarrierReceiptId(response: HttpResponseBase): Observable<LoadCarrierSorting> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadCarrierSorting>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class LoadingLocationsAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getByCustomerDivisionId(id: number): Observable<LoadingLocationAdministration[]> {
        let url_ = this.baseUrl + "/loadinglocationsadministration/division/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCustomerDivisionId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCustomerDivisionId(<any>response_);
                } catch (e) {
                    return <Observable<LoadingLocationAdministration[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingLocationAdministration[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByCustomerDivisionId(response: HttpResponseBase): Observable<LoadingLocationAdministration[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadingLocationAdministration[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getById(id: number): Observable<LoadingLocationAdministration> {
        let url_ = this.baseUrl + "/loadinglocationsadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<LoadingLocationAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingLocationAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LoadingLocationAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadingLocationAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    delete(id: number): Observable<LoadingLocationAdministration> {
        let url_ = this.baseUrl + "/loadinglocationsadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<LoadingLocationAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingLocationAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<LoadingLocationAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadingLocationAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    post(request: LoadingLocationsCreateRequest): Observable<LoadingLocationAdministration> {
        let url_ = this.baseUrl + "/loadinglocationsadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<LoadingLocationAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingLocationAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<LoadingLocationAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <LoadingLocationAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patch(request: LoadingLocationsUpdateRequest): Observable<LoadingLocationAdministration> {
        let url_ = this.baseUrl + "/loadinglocationsadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<LoadingLocationAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingLocationAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<LoadingLocationAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadingLocationAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadingLocationAdministration>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class LoadingLocationsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: LoadingLocationSearchRequest): Observable<IPaginationResultOfLoadingLocation> {
        let url_ = this.baseUrl + "/loading-locations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfLoadingLocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfLoadingLocation>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IPaginationResultOfLoadingLocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfLoadingLocation>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfLoadingLocation>(<any>null);
    }

    getById(id: number): Observable<LoadingLocation> {
        let url_ = this.baseUrl + "/loading-locations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<LoadingLocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingLocation>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<LoadingLocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadingLocation>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patch(id: number, request: UpdateLoadingLocationRequest): Observable<LoadingLocation> {
        let url_ = this.baseUrl + "/loading-locations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<LoadingLocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadingLocation>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<LoadingLocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadingLocation>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class MasterDataApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<MasterData> {
        let url_ = this.baseUrl + "/master-data";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<MasterData>><any>_observableThrow(e);
                }
            } else
                return <Observable<MasterData>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<MasterData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MasterData>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<MasterData>(<any>null);
    }

    updateCache(): Observable<void> {
        let url_ = this.baseUrl + "/master-data/updatecache";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class NumberSequencesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getByCustomerId(id: number): Observable<DocumentNumberSequence[]> {
        let url_ = this.baseUrl + "/number-sequences/customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCustomerId(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNumberSequence[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNumberSequence[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByCustomerId(response: HttpResponseBase): Observable<DocumentNumberSequence[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentNumberSequence[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		customerId?: number | null | undefined,
	}): Observable<LoadResult> {
        let url_ = this.baseUrl + "/number-sequences?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.customerId !== undefined && request.customerId !== null)
            url_ += "CustomerId=" + encodeURIComponent("" + request.customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadResult>(<any>null);
    }

    post(values?: string | null | undefined): Observable<DocumentNumberSequence> {
        let url_ = this.baseUrl + "/number-sequences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNumberSequence>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNumberSequence>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<DocumentNumberSequence> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <DocumentNumberSequence>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(key?: number | undefined, values?: string | null | undefined): Observable<DocumentNumberSequence> {
        let url_ = this.baseUrl + "/number-sequences";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (key === null || key === undefined)
            throw new Error("The parameter 'key' cannot be null.");
        else
            content_.append("key", key.toString());
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<DocumentNumberSequence>><any>_observableThrow(e);
                }
            } else
                return <Observable<DocumentNumberSequence>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<DocumentNumberSequence> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DocumentNumberSequence>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DocumentNumberSequence>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OfferingsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    searchLoadCarrierOfferings(request: {
		postingAccountId?: number | undefined,
		type?: OrderType | undefined,
		transportType?: OrderTransportType | undefined,
		loadCarrierId?: number | undefined,
		quantityType?: OrderQuantityType | undefined,
		loadCarrierQuantity?: number | undefined,
		baseLoadCarrierId?: (number | null)[] | null | undefined,
		lat?: number | undefined,
		lng?: number | undefined,
		radius?: number | undefined,
		date?: Date[] | null | undefined,
		stackHeightMin?: number | undefined,
		stackHeightMax?: number | undefined,
		supportsRearLoading?: boolean | undefined,
		supportsSideLoading?: boolean | undefined,
		supportsJumboVehicles?: boolean | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<LoadCarrierOffering[]> {
        let url_ = this.baseUrl + "/offerings/load-carriers?";
        if (request.postingAccountId === null)
            throw new Error("The parameter 'postingAccountId' cannot be null.");
        else if (request.postingAccountId !== undefined)
            url_ += "PostingAccountId=" + encodeURIComponent("" + request.postingAccountId) + "&";
        if (request.type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (request.type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + request.type) + "&";
        if (request.transportType === null)
            throw new Error("The parameter 'transportType' cannot be null.");
        else if (request.transportType !== undefined)
            url_ += "TransportType=" + encodeURIComponent("" + request.transportType) + "&";
        if (request.loadCarrierId === null)
            throw new Error("The parameter 'loadCarrierId' cannot be null.");
        else if (request.loadCarrierId !== undefined)
            url_ += "LoadCarrierId=" + encodeURIComponent("" + request.loadCarrierId) + "&";
        if (request.quantityType === null)
            throw new Error("The parameter 'quantityType' cannot be null.");
        else if (request.quantityType !== undefined)
            url_ += "QuantityType=" + encodeURIComponent("" + request.quantityType) + "&";
        if (request.loadCarrierQuantity === null)
            throw new Error("The parameter 'loadCarrierQuantity' cannot be null.");
        else if (request.loadCarrierQuantity !== undefined)
            url_ += "LoadCarrierQuantity=" + encodeURIComponent("" + request.loadCarrierQuantity) + "&";
        if (request.baseLoadCarrierId !== undefined && request.baseLoadCarrierId !== null)
            request.baseLoadCarrierId && request.baseLoadCarrierId.forEach(item => { url_ += "BaseLoadCarrierId=" + encodeURIComponent("" + item) + "&"; });
        if (request.lat === null)
            throw new Error("The parameter 'lat' cannot be null.");
        else if (request.lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + request.lat) + "&";
        if (request.lng === null)
            throw new Error("The parameter 'lng' cannot be null.");
        else if (request.lng !== undefined)
            url_ += "Lng=" + encodeURIComponent("" + request.lng) + "&";
        if (request.radius === null)
            throw new Error("The parameter 'radius' cannot be null.");
        else if (request.radius !== undefined)
            url_ += "Radius=" + encodeURIComponent("" + request.radius) + "&";
        if (request.date !== undefined && request.date !== null)
            request.date && request.date.forEach(item_ => { url_ += "Date=" + encodeURIComponent(item_ ? "" + item_.toJSON() : "null") + "&"; });
        if (request.stackHeightMin === null)
            throw new Error("The parameter 'stackHeightMin' cannot be null.");
        else if (request.stackHeightMin !== undefined)
            url_ += "StackHeightMin=" + encodeURIComponent("" + request.stackHeightMin) + "&";
        if (request.stackHeightMax === null)
            throw new Error("The parameter 'stackHeightMax' cannot be null.");
        else if (request.stackHeightMax !== undefined)
            url_ += "StackHeightMax=" + encodeURIComponent("" + request.stackHeightMax) + "&";
        if (request.supportsRearLoading === null)
            throw new Error("The parameter 'supportsRearLoading' cannot be null.");
        else if (request.supportsRearLoading !== undefined)
            url_ += "SupportsRearLoading=" + encodeURIComponent("" + request.supportsRearLoading) + "&";
        if (request.supportsSideLoading === null)
            throw new Error("The parameter 'supportsSideLoading' cannot be null.");
        else if (request.supportsSideLoading !== undefined)
            url_ += "SupportsSideLoading=" + encodeURIComponent("" + request.supportsSideLoading) + "&";
        if (request.supportsJumboVehicles === null)
            throw new Error("The parameter 'supportsJumboVehicles' cannot be null.");
        else if (request.supportsJumboVehicles !== undefined)
            url_ += "SupportsJumboVehicles=" + encodeURIComponent("" + request.supportsJumboVehicles) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchLoadCarrierOfferings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchLoadCarrierOfferings(<any>response_);
                } catch (e) {
                    return <Observable<LoadCarrierOffering[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadCarrierOffering[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearchLoadCarrierOfferings(response: HttpResponseBase): Observable<LoadCarrierOffering[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadCarrierOffering[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    searchTransportOfferings(request: {
		divisionId?: number | undefined,
		status?: TransportOfferingStatus[] | null | undefined,
		loadCarrierType?: number[] | null | undefined,
		supplyEarliestFulfillmentDateFrom?: Date | null | undefined,
		supplyEarliestFulfillmentDateTo?: Date | null | undefined,
		demandLatestFulfillmentDateFrom?: Date | null | undefined,
		demandLatestFulfillmentDateTo?: Date | null | undefined,
		supplyPostalCode?: string | null | undefined,
		demandPostalCode?: string | null | undefined,
		lat?: number | undefined,
		lng?: number | undefined,
		radius?: number | undefined,
		stackHeightMin?: number | null | undefined,
		stackHeightMax?: number | null | undefined,
		supportsRearLoading?: boolean | undefined,
		supportsSideLoading?: boolean | undefined,
		supportsJumboVehicles?: boolean | undefined,
		sortBy?: TransportOfferingSortOption | undefined,
		sortDirection?: ListSortDirection | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<IPaginationResultOfTransportOffering> {
        let url_ = this.baseUrl + "/offerings/transports?";
        if (request.divisionId === null)
            throw new Error("The parameter 'divisionId' cannot be null.");
        else if (request.divisionId !== undefined)
            url_ += "DivisionId=" + encodeURIComponent("" + request.divisionId) + "&";
        if (request.status !== undefined && request.status !== null)
            request.status && request.status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierType !== undefined && request.loadCarrierType !== null)
            request.loadCarrierType && request.loadCarrierType.forEach(item => { url_ += "LoadCarrierType=" + encodeURIComponent("" + item) + "&"; });
        if (request.supplyEarliestFulfillmentDateFrom !== undefined && request.supplyEarliestFulfillmentDateFrom !== null)
            url_ += "SupplyEarliestFulfillmentDateFrom=" + encodeURIComponent(request.supplyEarliestFulfillmentDateFrom ? "" + request.supplyEarliestFulfillmentDateFrom.toJSON() : "") + "&";
        if (request.supplyEarliestFulfillmentDateTo !== undefined && request.supplyEarliestFulfillmentDateTo !== null)
            url_ += "SupplyEarliestFulfillmentDateTo=" + encodeURIComponent(request.supplyEarliestFulfillmentDateTo ? "" + request.supplyEarliestFulfillmentDateTo.toJSON() : "") + "&";
        if (request.demandLatestFulfillmentDateFrom !== undefined && request.demandLatestFulfillmentDateFrom !== null)
            url_ += "DemandLatestFulfillmentDateFrom=" + encodeURIComponent(request.demandLatestFulfillmentDateFrom ? "" + request.demandLatestFulfillmentDateFrom.toJSON() : "") + "&";
        if (request.demandLatestFulfillmentDateTo !== undefined && request.demandLatestFulfillmentDateTo !== null)
            url_ += "DemandLatestFulfillmentDateTo=" + encodeURIComponent(request.demandLatestFulfillmentDateTo ? "" + request.demandLatestFulfillmentDateTo.toJSON() : "") + "&";
        if (request.supplyPostalCode !== undefined && request.supplyPostalCode !== null)
            url_ += "SupplyPostalCode=" + encodeURIComponent("" + request.supplyPostalCode) + "&";
        if (request.demandPostalCode !== undefined && request.demandPostalCode !== null)
            url_ += "DemandPostalCode=" + encodeURIComponent("" + request.demandPostalCode) + "&";
        if (request.lat === null)
            throw new Error("The parameter 'lat' cannot be null.");
        else if (request.lat !== undefined)
            url_ += "Lat=" + encodeURIComponent("" + request.lat) + "&";
        if (request.lng === null)
            throw new Error("The parameter 'lng' cannot be null.");
        else if (request.lng !== undefined)
            url_ += "Lng=" + encodeURIComponent("" + request.lng) + "&";
        if (request.radius === null)
            throw new Error("The parameter 'radius' cannot be null.");
        else if (request.radius !== undefined)
            url_ += "Radius=" + encodeURIComponent("" + request.radius) + "&";
        if (request.stackHeightMin !== undefined && request.stackHeightMin !== null)
            url_ += "StackHeightMin=" + encodeURIComponent("" + request.stackHeightMin) + "&";
        if (request.stackHeightMax !== undefined && request.stackHeightMax !== null)
            url_ += "StackHeightMax=" + encodeURIComponent("" + request.stackHeightMax) + "&";
        if (request.supportsRearLoading === null)
            throw new Error("The parameter 'supportsRearLoading' cannot be null.");
        else if (request.supportsRearLoading !== undefined)
            url_ += "SupportsRearLoading=" + encodeURIComponent("" + request.supportsRearLoading) + "&";
        if (request.supportsSideLoading === null)
            throw new Error("The parameter 'supportsSideLoading' cannot be null.");
        else if (request.supportsSideLoading !== undefined)
            url_ += "SupportsSideLoading=" + encodeURIComponent("" + request.supportsSideLoading) + "&";
        if (request.supportsJumboVehicles === null)
            throw new Error("The parameter 'supportsJumboVehicles' cannot be null.");
        else if (request.supportsJumboVehicles !== undefined)
            url_ += "SupportsJumboVehicles=" + encodeURIComponent("" + request.supportsJumboVehicles) + "&";
        if (request.sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (request.sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + request.sortBy) + "&";
        if (request.sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (request.sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + request.sortDirection) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchTransportOfferings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchTransportOfferings(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfTransportOffering>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfTransportOffering>><any>_observableThrow(response_);
        }));
    }

    protected processSearchTransportOfferings(response: HttpResponseBase): Observable<IPaginationResultOfTransportOffering> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfTransportOffering>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfTransportOffering>(<any>null);
    }

    getTransportOffering(id: number): Observable<TransportOffering> {
        let url_ = this.baseUrl + "/offerings/transports/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransportOffering(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransportOffering(<any>response_);
                } catch (e) {
                    return <Observable<TransportOffering>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportOffering>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransportOffering(response: HttpResponseBase): Observable<TransportOffering> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransportOffering>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    createTransportOfferingBid(id: number, request: TransportOfferingBidCreateRequest): Observable<TransportOfferingBid> {
        let url_ = this.baseUrl + "/offerings/transports/{id}/bids";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTransportOfferingBid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTransportOfferingBid(<any>response_);
                } catch (e) {
                    return <Observable<TransportOfferingBid>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportOfferingBid>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTransportOfferingBid(response: HttpResponseBase): Observable<TransportOfferingBid> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <TransportOfferingBid>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportOfferingBid>(<any>null);
    }

    cancelTransportOfferingBid(id: number, bidId: number): Observable<TransportOfferingBid> {
        let url_ = this.baseUrl + "/offerings/transports/{id}/bids/{bidId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (bidId === undefined || bidId === null)
            throw new Error("The parameter 'bidId' must be defined.");
        url_ = url_.replace("{bidId}", encodeURIComponent("" + bidId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelTransportOfferingBid(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelTransportOfferingBid(<any>response_);
                } catch (e) {
                    return <Observable<TransportOfferingBid>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportOfferingBid>><any>_observableThrow(response_);
        }));
    }

    protected processCancelTransportOfferingBid(response: HttpResponseBase): Observable<TransportOfferingBid> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransportOfferingBid>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportOfferingBid>(<any>null);
    }

    acceptBidForTransportOffering(id: number, request: TransportOfferingBidAcceptRequest): Observable<TransportOffering> {
        let url_ = this.baseUrl + "/offerings/transports/{id}/accept-bid";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptBidForTransportOffering(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptBidForTransportOffering(<any>response_);
                } catch (e) {
                    return <Observable<TransportOffering>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportOffering>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptBidForTransportOffering(response: HttpResponseBase): Observable<TransportOffering> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransportOffering>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportOffering>(<any>null);
    }

    acceptTransportOffering(id: number): Observable<TransportOffering> {
        let url_ = this.baseUrl + "/offerings/transports/{id}/accept";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptTransportOffering(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptTransportOffering(<any>response_);
                } catch (e) {
                    return <Observable<TransportOffering>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportOffering>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptTransportOffering(response: HttpResponseBase): Observable<TransportOffering> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransportOffering>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportOffering>(<any>null);
    }

    declineTransportOffering(id: number): Observable<TransportOffering> {
        let url_ = this.baseUrl + "/offerings/transports/{id}/decline";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeclineTransportOffering(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeclineTransportOffering(<any>response_);
                } catch (e) {
                    return <Observable<TransportOffering>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransportOffering>><any>_observableThrow(response_);
        }));
    }

    protected processDeclineTransportOffering(response: HttpResponseBase): Observable<TransportOffering> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TransportOffering>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransportOffering>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderGroupsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(request: {
		id?: number[] | null | undefined,
		orderId?: number[] | null | undefined,
		orderLoadId?: number[] | null | undefined,
		loadCarrierReceiptId?: number[] | null | undefined,
	}): Observable<OrderGroup[]> {
        let url_ = this.baseUrl + "/ordergroups?";
        if (request.id !== undefined && request.id !== null)
            request.id && request.id.forEach(item => { url_ += "Id=" + encodeURIComponent("" + item) + "&"; });
        if (request.orderId !== undefined && request.orderId !== null)
            request.orderId && request.orderId.forEach(item => { url_ += "OrderId=" + encodeURIComponent("" + item) + "&"; });
        if (request.orderLoadId !== undefined && request.orderLoadId !== null)
            request.orderLoadId && request.orderLoadId.forEach(item => { url_ += "OrderLoadId=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierReceiptId !== undefined && request.loadCarrierReceiptId !== null)
            request.loadCarrierReceiptId && request.loadCarrierReceiptId.forEach(item => { url_ += "LoadCarrierReceiptId=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<OrderGroup[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderGroup[]>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<OrderGroup[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderGroup[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderGroup[]>(<any>null);
    }

    post(request: OrderGroupsCreateRequest): Observable<OrderGroup> {
        let url_ = this.baseUrl + "/ordergroups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<OrderGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderGroup>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<OrderGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <OrderGroup>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    getById(id: number): Observable<OrderGroup> {
        let url_ = this.baseUrl + "/ordergroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<OrderGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderGroup>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<OrderGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderGroup>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    patch(id: number, request: OrderGroupsUpdateRequest): Observable<OrderGroup> {
        let url_ = this.baseUrl + "/ordergroups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<OrderGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderGroup>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<OrderGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderGroup>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    patchOrderGroupCancelled(id: number, request: OrderGroupCancelRequest): Observable<OrderGroup> {
        let url_ = this.baseUrl + "/ordergroups/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchOrderGroupCancelled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchOrderGroupCancelled(<any>response_);
                } catch (e) {
                    return <Observable<OrderGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderGroup>><any>_observableThrow(response_);
        }));
    }

    protected processPatchOrderGroupCancelled(response: HttpResponseBase): Observable<OrderGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderGroup>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderLoadsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(request: {
		divisionId?: number[] | null | undefined,
		digitalCode?: string | null | undefined,
		type?: OrderType[] | null | undefined,
		transportType?: OrderTransportType[] | null | undefined,
		status?: OrderLoadStatus[] | null | undefined,
		loadCarrierQuantityFrom?: number | null | undefined,
		loadCarrierQuantityTo?: number | null | undefined,
		postingAccountId?: number[] | null | undefined,
		loadingLocationId?: number[] | null | undefined,
		loadCarrierId?: number[] | null | undefined,
		baseLoadCarrierId?: number[] | null | undefined,
		plannedFulfilmentDateFrom?: Date | null | undefined,
		plannedFulfilmentDateTo?: Date | null | undefined,
		actualFulfillmentDateFrom?: Date | null | undefined,
		actualFulfillmentDateTo?: Date | null | undefined,
		hasDplNote?: boolean | null | undefined,
		sortBy?: OrderLoadSearchRequestSortOptions | undefined,
		sortDirection?: ListSortDirection | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<IPaginationResultOfOrderLoad> {
        let url_ = this.baseUrl + "/order-loads?";
        if (request.divisionId !== undefined && request.divisionId !== null)
            request.divisionId && request.divisionId.forEach(item => { url_ += "DivisionId=" + encodeURIComponent("" + item) + "&"; });
        if (request.digitalCode !== undefined && request.digitalCode !== null)
            url_ += "DigitalCode=" + encodeURIComponent("" + request.digitalCode) + "&";
        if (request.type !== undefined && request.type !== null)
            request.type && request.type.forEach(item => { url_ += "Type=" + encodeURIComponent("" + item) + "&"; });
        if (request.transportType !== undefined && request.transportType !== null)
            request.transportType && request.transportType.forEach(item => { url_ += "TransportType=" + encodeURIComponent("" + item) + "&"; });
        if (request.status !== undefined && request.status !== null)
            request.status && request.status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierQuantityFrom !== undefined && request.loadCarrierQuantityFrom !== null)
            url_ += "LoadCarrierQuantityFrom=" + encodeURIComponent("" + request.loadCarrierQuantityFrom) + "&";
        if (request.loadCarrierQuantityTo !== undefined && request.loadCarrierQuantityTo !== null)
            url_ += "LoadCarrierQuantityTo=" + encodeURIComponent("" + request.loadCarrierQuantityTo) + "&";
        if (request.postingAccountId !== undefined && request.postingAccountId !== null)
            request.postingAccountId && request.postingAccountId.forEach(item => { url_ += "PostingAccountId=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadingLocationId !== undefined && request.loadingLocationId !== null)
            request.loadingLocationId && request.loadingLocationId.forEach(item => { url_ += "LoadingLocationId=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierId !== undefined && request.loadCarrierId !== null)
            request.loadCarrierId && request.loadCarrierId.forEach(item => { url_ += "LoadCarrierId=" + encodeURIComponent("" + item) + "&"; });
        if (request.baseLoadCarrierId !== undefined && request.baseLoadCarrierId !== null)
            request.baseLoadCarrierId && request.baseLoadCarrierId.forEach(item => { url_ += "BaseLoadCarrierId=" + encodeURIComponent("" + item) + "&"; });
        if (request.plannedFulfilmentDateFrom !== undefined && request.plannedFulfilmentDateFrom !== null)
            url_ += "PlannedFulfilmentDateFrom=" + encodeURIComponent(request.plannedFulfilmentDateFrom ? "" + request.plannedFulfilmentDateFrom.toJSON() : "") + "&";
        if (request.plannedFulfilmentDateTo !== undefined && request.plannedFulfilmentDateTo !== null)
            url_ += "PlannedFulfilmentDateTo=" + encodeURIComponent(request.plannedFulfilmentDateTo ? "" + request.plannedFulfilmentDateTo.toJSON() : "") + "&";
        if (request.actualFulfillmentDateFrom !== undefined && request.actualFulfillmentDateFrom !== null)
            url_ += "ActualFulfillmentDateFrom=" + encodeURIComponent(request.actualFulfillmentDateFrom ? "" + request.actualFulfillmentDateFrom.toJSON() : "") + "&";
        if (request.actualFulfillmentDateTo !== undefined && request.actualFulfillmentDateTo !== null)
            url_ += "ActualFulfillmentDateTo=" + encodeURIComponent(request.actualFulfillmentDateTo ? "" + request.actualFulfillmentDateTo.toJSON() : "") + "&";
        if (request.hasDplNote !== undefined && request.hasDplNote !== null)
            url_ += "HasDplNote=" + encodeURIComponent("" + request.hasDplNote) + "&";
        if (request.sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (request.sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + request.sortBy) + "&";
        if (request.sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (request.sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + request.sortDirection) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfOrderLoad>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfOrderLoad>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<IPaginationResultOfOrderLoad> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfOrderLoad>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfOrderLoad>(<any>null);
    }

    cancel(id: number, request: OrderLoadCancelRequest): Observable<OrderLoad> {
        let url_ = this.baseUrl + "/order-loads/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<OrderLoad>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderLoad>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<OrderLoad> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderLoad>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderLoad>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrderMatchesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param code (optional) 
     * @param statuses (optional) 
     * @param postingAccountId (optional) 
     * @param page (optional) 
     * @param limit (optional) 
     * @deprecated
     */
    get(request: {
		code?: string | null | undefined,
		statuses?: OrderMatchStatus[] | null | undefined,
		postingAccountId?: number[] | null | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<IPaginationResultOfOrderMatch> {
        let url_ = this.baseUrl + "/ordermatches?";
        if (request.code !== undefined && request.code !== null)
            url_ += "Code=" + encodeURIComponent("" + request.code) + "&";
        if (request.statuses !== undefined && request.statuses !== null)
            request.statuses && request.statuses.forEach(item => { url_ += "Statuses=" + encodeURIComponent("" + item) + "&"; });
        if (request.postingAccountId !== undefined && request.postingAccountId !== null)
            request.postingAccountId && request.postingAccountId.forEach(item => { url_ += "PostingAccountId=" + encodeURIComponent("" + item) + "&"; });
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfOrderMatch>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfOrderMatch>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IPaginationResultOfOrderMatch> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfOrderMatch>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfOrderMatch>(<any>null);
    }

    post(request: OrderMatchesCreateRequest): Observable<OrderMatch> {
        let url_ = this.baseUrl + "/ordermatches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<OrderMatch>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderMatch>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<OrderMatch> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <OrderMatch>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    getById(id: number): Observable<OrderMatch> {
        let url_ = this.baseUrl + "/ordermatches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<OrderMatch>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderMatch>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<OrderMatch> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderMatch>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    patch(id: number, request: OrderMatchesUpdateRequest): Observable<OrderMatch> {
        let url_ = this.baseUrl + "/ordermatches/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<OrderMatch>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderMatch>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<OrderMatch> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderMatch>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    patchOrderMatchCancelled(id: number): Observable<OrderMatch> {
        let url_ = this.baseUrl + "/ordermatches/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchOrderMatchCancelled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchOrderMatchCancelled(<any>response_);
                } catch (e) {
                    return <Observable<OrderMatch>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderMatch>><any>_observableThrow(response_);
        }));
    }

    protected processPatchOrderMatchCancelled(response: HttpResponseBase): Observable<OrderMatch> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderMatch>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderMatch>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrdersApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    search(request: {
		digitalCode?: string | null | undefined,
		type?: OrderType[] | null | undefined,
		transportType?: OrderTransportType[] | null | undefined,
		status?: OrderStatus[] | null | undefined,
		quantityType?: OrderQuantityType[] | null | undefined,
		loadCarrierQuantityFrom?: number | null | undefined,
		loadCarrierQuantityTo?: number | null | undefined,
		currentLoadCarrierQuantityFrom?: number | null | undefined,
		currentLoadCarrierQuantityTo?: number | null | undefined,
		divisionId?: number[] | null | undefined,
		postingAccountId?: number[] | null | undefined,
		loadingLocationId?: number[] | null | undefined,
		loadCarrierId?: number[] | null | undefined,
		baseLoadCarrierId?: number[] | null | undefined,
		orderDateFrom?: Date | null | undefined,
		orderDateTo?: Date | null | undefined,
		fulfilmentDateFrom?: Date | null | undefined,
		fulfilmentDateTo?: Date | null | undefined,
		confirmedFulfillmentDateFrom?: Date | null | undefined,
		confirmedFulfillmentDateTo?: Date | null | undefined,
		hasDplNote?: boolean | null | undefined,
		sortBy?: OrderSearchRequestSortOptions | undefined,
		sortDirection?: ListSortDirection | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<IPaginationResultOfOrder> {
        let url_ = this.baseUrl + "/orders?";
        if (request.digitalCode !== undefined && request.digitalCode !== null)
            url_ += "DigitalCode=" + encodeURIComponent("" + request.digitalCode) + "&";
        if (request.type !== undefined && request.type !== null)
            request.type && request.type.forEach(item => { url_ += "Type=" + encodeURIComponent("" + item) + "&"; });
        if (request.transportType !== undefined && request.transportType !== null)
            request.transportType && request.transportType.forEach(item => { url_ += "TransportType=" + encodeURIComponent("" + item) + "&"; });
        if (request.status !== undefined && request.status !== null)
            request.status && request.status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (request.quantityType !== undefined && request.quantityType !== null)
            request.quantityType && request.quantityType.forEach(item => { url_ += "QuantityType=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierQuantityFrom !== undefined && request.loadCarrierQuantityFrom !== null)
            url_ += "LoadCarrierQuantityFrom=" + encodeURIComponent("" + request.loadCarrierQuantityFrom) + "&";
        if (request.loadCarrierQuantityTo !== undefined && request.loadCarrierQuantityTo !== null)
            url_ += "LoadCarrierQuantityTo=" + encodeURIComponent("" + request.loadCarrierQuantityTo) + "&";
        if (request.currentLoadCarrierQuantityFrom !== undefined && request.currentLoadCarrierQuantityFrom !== null)
            url_ += "CurrentLoadCarrierQuantityFrom=" + encodeURIComponent("" + request.currentLoadCarrierQuantityFrom) + "&";
        if (request.currentLoadCarrierQuantityTo !== undefined && request.currentLoadCarrierQuantityTo !== null)
            url_ += "CurrentLoadCarrierQuantityTo=" + encodeURIComponent("" + request.currentLoadCarrierQuantityTo) + "&";
        if (request.divisionId !== undefined && request.divisionId !== null)
            request.divisionId && request.divisionId.forEach(item => { url_ += "DivisionId=" + encodeURIComponent("" + item) + "&"; });
        if (request.postingAccountId !== undefined && request.postingAccountId !== null)
            request.postingAccountId && request.postingAccountId.forEach(item => { url_ += "PostingAccountId=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadingLocationId !== undefined && request.loadingLocationId !== null)
            request.loadingLocationId && request.loadingLocationId.forEach(item => { url_ += "LoadingLocationId=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierId !== undefined && request.loadCarrierId !== null)
            request.loadCarrierId && request.loadCarrierId.forEach(item => { url_ += "LoadCarrierId=" + encodeURIComponent("" + item) + "&"; });
        if (request.baseLoadCarrierId !== undefined && request.baseLoadCarrierId !== null)
            request.baseLoadCarrierId && request.baseLoadCarrierId.forEach(item => { url_ += "BaseLoadCarrierId=" + encodeURIComponent("" + item) + "&"; });
        if (request.orderDateFrom !== undefined && request.orderDateFrom !== null)
            url_ += "OrderDateFrom=" + encodeURIComponent(request.orderDateFrom ? "" + request.orderDateFrom.toJSON() : "") + "&";
        if (request.orderDateTo !== undefined && request.orderDateTo !== null)
            url_ += "OrderDateTo=" + encodeURIComponent(request.orderDateTo ? "" + request.orderDateTo.toJSON() : "") + "&";
        if (request.fulfilmentDateFrom !== undefined && request.fulfilmentDateFrom !== null)
            url_ += "FulfilmentDateFrom=" + encodeURIComponent(request.fulfilmentDateFrom ? "" + request.fulfilmentDateFrom.toJSON() : "") + "&";
        if (request.fulfilmentDateTo !== undefined && request.fulfilmentDateTo !== null)
            url_ += "FulfilmentDateTo=" + encodeURIComponent(request.fulfilmentDateTo ? "" + request.fulfilmentDateTo.toJSON() : "") + "&";
        if (request.confirmedFulfillmentDateFrom !== undefined && request.confirmedFulfillmentDateFrom !== null)
            url_ += "ConfirmedFulfillmentDateFrom=" + encodeURIComponent(request.confirmedFulfillmentDateFrom ? "" + request.confirmedFulfillmentDateFrom.toJSON() : "") + "&";
        if (request.confirmedFulfillmentDateTo !== undefined && request.confirmedFulfillmentDateTo !== null)
            url_ += "ConfirmedFulfillmentDateTo=" + encodeURIComponent(request.confirmedFulfillmentDateTo ? "" + request.confirmedFulfillmentDateTo.toJSON() : "") + "&";
        if (request.hasDplNote !== undefined && request.hasDplNote !== null)
            url_ += "HasDplNote=" + encodeURIComponent("" + request.hasDplNote) + "&";
        if (request.sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (request.sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + request.sortBy) + "&";
        if (request.sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (request.sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + request.sortDirection) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearch(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfOrder>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfOrder>><any>_observableThrow(response_);
        }));
    }

    protected processSearch(response: HttpResponseBase): Observable<IPaginationResultOfOrder> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfOrder>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfOrder>(<any>null);
    }

    /**
     * @deprecated
     */
    getById(id: number): Observable<Order> {
        let url_ = this.baseUrl + "/orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<Order>><any>_observableThrow(e);
                }
            } else
                return <Observable<Order>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Order>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    patch(id: number, request: OrderUpdateRequest): Observable<Order> {
        let url_ = this.baseUrl + "/orders/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<Order>><any>_observableThrow(e);
                }
            } else
                return <Observable<Order>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Order>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    cancel(id: number, request: OrderCancelRequest): Observable<Order> {
        let url_ = this.baseUrl + "/orders/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<Order>><any>_observableThrow(e);
                }
            } else
                return <Observable<Order>><any>_observableThrow(response_);
        }));
    }

    protected processCancel(response: HttpResponseBase): Observable<Order> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Order>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Order>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrdersSummariesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		digitalCode?: string | null | undefined,
		type?: OrderType[] | null | undefined,
		transportType?: OrderTransportType[] | null | undefined,
		status?: OrderStatus[] | null | undefined,
		quantityType?: OrderQuantityType[] | null | undefined,
		loadCarrierQuantityFrom?: number | null | undefined,
		loadCarrierQuantityTo?: number | null | undefined,
		currentLoadCarrierQuantityFrom?: number | null | undefined,
		currentLoadCarrierQuantityTo?: number | null | undefined,
		divisionId?: number[] | null | undefined,
		postingAccountId?: number[] | null | undefined,
		loadingLocationId?: number[] | null | undefined,
		loadCarrierId?: number[] | null | undefined,
		baseLoadCarrierId?: number[] | null | undefined,
		orderDateFrom?: Date | null | undefined,
		orderDateTo?: Date | null | undefined,
		fulfilmentDateFrom?: Date | null | undefined,
		fulfilmentDateTo?: Date | null | undefined,
		confirmedFulfillmentDateFrom?: Date | null | undefined,
		confirmedFulfillmentDateTo?: Date | null | undefined,
		hasDplNote?: boolean | null | undefined,
		sortBy?: OrderSearchRequestSortOptions | undefined,
		sortDirection?: ListSortDirection | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<OrderSummary[]> {
        let url_ = this.baseUrl + "/orderssummaries?";
        if (request.digitalCode !== undefined && request.digitalCode !== null)
            url_ += "DigitalCode=" + encodeURIComponent("" + request.digitalCode) + "&";
        if (request.type !== undefined && request.type !== null)
            request.type && request.type.forEach(item => { url_ += "Type=" + encodeURIComponent("" + item) + "&"; });
        if (request.transportType !== undefined && request.transportType !== null)
            request.transportType && request.transportType.forEach(item => { url_ += "TransportType=" + encodeURIComponent("" + item) + "&"; });
        if (request.status !== undefined && request.status !== null)
            request.status && request.status.forEach(item => { url_ += "Status=" + encodeURIComponent("" + item) + "&"; });
        if (request.quantityType !== undefined && request.quantityType !== null)
            request.quantityType && request.quantityType.forEach(item => { url_ += "QuantityType=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierQuantityFrom !== undefined && request.loadCarrierQuantityFrom !== null)
            url_ += "LoadCarrierQuantityFrom=" + encodeURIComponent("" + request.loadCarrierQuantityFrom) + "&";
        if (request.loadCarrierQuantityTo !== undefined && request.loadCarrierQuantityTo !== null)
            url_ += "LoadCarrierQuantityTo=" + encodeURIComponent("" + request.loadCarrierQuantityTo) + "&";
        if (request.currentLoadCarrierQuantityFrom !== undefined && request.currentLoadCarrierQuantityFrom !== null)
            url_ += "CurrentLoadCarrierQuantityFrom=" + encodeURIComponent("" + request.currentLoadCarrierQuantityFrom) + "&";
        if (request.currentLoadCarrierQuantityTo !== undefined && request.currentLoadCarrierQuantityTo !== null)
            url_ += "CurrentLoadCarrierQuantityTo=" + encodeURIComponent("" + request.currentLoadCarrierQuantityTo) + "&";
        if (request.divisionId !== undefined && request.divisionId !== null)
            request.divisionId && request.divisionId.forEach(item => { url_ += "DivisionId=" + encodeURIComponent("" + item) + "&"; });
        if (request.postingAccountId !== undefined && request.postingAccountId !== null)
            request.postingAccountId && request.postingAccountId.forEach(item => { url_ += "PostingAccountId=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadingLocationId !== undefined && request.loadingLocationId !== null)
            request.loadingLocationId && request.loadingLocationId.forEach(item => { url_ += "LoadingLocationId=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierId !== undefined && request.loadCarrierId !== null)
            request.loadCarrierId && request.loadCarrierId.forEach(item => { url_ += "LoadCarrierId=" + encodeURIComponent("" + item) + "&"; });
        if (request.baseLoadCarrierId !== undefined && request.baseLoadCarrierId !== null)
            request.baseLoadCarrierId && request.baseLoadCarrierId.forEach(item => { url_ += "BaseLoadCarrierId=" + encodeURIComponent("" + item) + "&"; });
        if (request.orderDateFrom !== undefined && request.orderDateFrom !== null)
            url_ += "OrderDateFrom=" + encodeURIComponent(request.orderDateFrom ? "" + request.orderDateFrom.toJSON() : "") + "&";
        if (request.orderDateTo !== undefined && request.orderDateTo !== null)
            url_ += "OrderDateTo=" + encodeURIComponent(request.orderDateTo ? "" + request.orderDateTo.toJSON() : "") + "&";
        if (request.fulfilmentDateFrom !== undefined && request.fulfilmentDateFrom !== null)
            url_ += "FulfilmentDateFrom=" + encodeURIComponent(request.fulfilmentDateFrom ? "" + request.fulfilmentDateFrom.toJSON() : "") + "&";
        if (request.fulfilmentDateTo !== undefined && request.fulfilmentDateTo !== null)
            url_ += "FulfilmentDateTo=" + encodeURIComponent(request.fulfilmentDateTo ? "" + request.fulfilmentDateTo.toJSON() : "") + "&";
        if (request.confirmedFulfillmentDateFrom !== undefined && request.confirmedFulfillmentDateFrom !== null)
            url_ += "ConfirmedFulfillmentDateFrom=" + encodeURIComponent(request.confirmedFulfillmentDateFrom ? "" + request.confirmedFulfillmentDateFrom.toJSON() : "") + "&";
        if (request.confirmedFulfillmentDateTo !== undefined && request.confirmedFulfillmentDateTo !== null)
            url_ += "ConfirmedFulfillmentDateTo=" + encodeURIComponent(request.confirmedFulfillmentDateTo ? "" + request.confirmedFulfillmentDateTo.toJSON() : "") + "&";
        if (request.hasDplNote !== undefined && request.hasDplNote !== null)
            url_ += "HasDplNote=" + encodeURIComponent("" + request.hasDplNote) + "&";
        if (request.sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (request.sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + request.sortBy) + "&";
        if (request.sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (request.sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + request.sortDirection) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<OrderSummary[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrderSummary[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<OrderSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrderSummary[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrderSummary[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class OrganizationsAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getById(id: number): Observable<OrganizationScopedDataSet[]> {
        let url_ = this.baseUrl + "/organizationsadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationScopedDataSet[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationScopedDataSet[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<OrganizationScopedDataSet[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OrganizationScopedDataSet[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    delete(id: number): Observable<Organization> {
        let url_ = this.baseUrl + "/organizationsadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<Organization>><any>_observableThrow(e);
                }
            } else
                return <Observable<Organization>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<Organization> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Organization>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getOrganizationById(id: number): Observable<Organization> {
        let url_ = this.baseUrl + "/organizationsadministration/organization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationById(<any>response_);
                } catch (e) {
                    return <Observable<Organization>><any>_observableThrow(e);
                }
            } else
                return <Observable<Organization>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationById(response: HttpResponseBase): Observable<Organization> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Organization>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(): Observable<Organization[]> {
        let url_ = this.baseUrl + "/organizationsadministration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Organization[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Organization[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Organization[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Organization[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Organization[]>(<any>null);
    }

    post(request: OrganizationCreateRequest): Observable<Organization> {
        let url_ = this.baseUrl + "/organizationsadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<Organization>><any>_observableThrow(e);
                }
            } else
                return <Observable<Organization>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<Organization> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Organization>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patch(request: OrganizationUpdateRequest): Observable<Organization> {
        let url_ = this.baseUrl + "/organizationsadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<Organization>><any>_observableThrow(e);
                }
            } else
                return <Observable<Organization>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<Organization> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Organization>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Organization>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PartnerDirectoriesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<PartnerDirectory[]> {
        let url_ = this.baseUrl + "/partner-directories";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PartnerDirectory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PartnerDirectory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PartnerDirectory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PartnerDirectory[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PartnerDirectory[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PartnersAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getById(id: number): Observable<Partner> {
        let url_ = this.baseUrl + "/partnersadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<Partner>><any>_observableThrow(e);
                }
            } else
                return <Observable<Partner>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Partner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Partner>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getByName(name: string | null): Observable<Partner[]> {
        let url_ = this.baseUrl + "/partnersadministration/company/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByName(<any>response_);
                } catch (e) {
                    return <Observable<Partner[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Partner[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByName(response: HttpResponseBase): Observable<Partner[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Partner[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Partner[]>(<any>null);
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
	}): Observable<LoadResult> {
        let url_ = this.baseUrl + "/partnersadministration?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadResult>(<any>null);
    }

    post(request: PartnersCreateRequest): Observable<Partner> {
        let url_ = this.baseUrl + "/partnersadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<Partner>><any>_observableThrow(e);
                }
            } else
                return <Observable<Partner>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<Partner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Partner>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(key?: number | undefined, values?: string | null | undefined): Observable<Partner> {
        let url_ = this.baseUrl + "/partnersadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (key === null || key === undefined)
            throw new Error("The parameter 'key' cannot be null.");
        else
            content_.append("key", key.toString());
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<Partner>><any>_observableThrow(e);
                }
            } else
                return <Observable<Partner>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<Partner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Partner>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Partner>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PartnersApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		id?: number | undefined,
		companyName?: string | null | undefined,
		city?: string | null | undefined,
		customerPartnerDirectoryId?: number | null | undefined,
		country?: string | null | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<IPaginationResultOfCustomerPartner> {
        let url_ = this.baseUrl + "/partners?";
        if (request.id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (request.id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + request.id) + "&";
        if (request.companyName !== undefined && request.companyName !== null)
            url_ += "CompanyName=" + encodeURIComponent("" + request.companyName) + "&";
        if (request.city !== undefined && request.city !== null)
            url_ += "City=" + encodeURIComponent("" + request.city) + "&";
        if (request.customerPartnerDirectoryId !== undefined && request.customerPartnerDirectoryId !== null)
            url_ += "CustomerPartnerDirectoryId=" + encodeURIComponent("" + request.customerPartnerDirectoryId) + "&";
        if (request.country !== undefined && request.country !== null)
            url_ += "Country=" + encodeURIComponent("" + request.country) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfCustomerPartner>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfCustomerPartner>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IPaginationResultOfCustomerPartner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfCustomerPartner>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfCustomerPartner>(<any>null);
    }

    post(request: CustomerPartnersCreateRequest): Observable<CustomerPartner> {
        let url_ = this.baseUrl + "/partners";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<CustomerPartner>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerPartner>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<CustomerPartner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <CustomerPartner>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getById(id: number): Observable<CustomerPartner> {
        let url_ = this.baseUrl + "/partners/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<CustomerPartner>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerPartner>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<CustomerPartner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerPartner>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    patch(id: number, request: CustomerPartnersUpdateRequest): Observable<CustomerPartner> {
        let url_ = this.baseUrl + "/partners/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<CustomerPartner>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerPartner>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<CustomerPartner> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CustomerPartner>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/partners/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class PermissionsAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    all(request: {
		customerId?: number | null | undefined,
		organizationId?: number | null | undefined,
		divisionId?: number | null | undefined,
	}): Observable<GroupPermission[]> {
        let url_ = this.baseUrl + "/permissionsadministration/all?";
        if (request.customerId !== undefined && request.customerId !== null)
            url_ += "CustomerId=" + encodeURIComponent("" + request.customerId) + "&";
        if (request.organizationId !== undefined && request.organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + request.organizationId) + "&";
        if (request.divisionId !== undefined && request.divisionId !== null)
            url_ += "DivisionId=" + encodeURIComponent("" + request.divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(<any>response_);
                } catch (e) {
                    return <Observable<GroupPermission[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GroupPermission[]>><any>_observableThrow(response_);
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<GroupPermission[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GroupPermission[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GroupPermission[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PostingAccountBalancesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		postingAccountId?: number | undefined,
		loadCarrierTypeId?: number | undefined,
		refLtmsArticleId?: number | undefined,
		forceBalanceCalculation?: boolean | undefined,
	}): Observable<BalancesSummary> {
        let url_ = this.baseUrl + "/postingaccountbalances?";
        if (request.postingAccountId === null)
            throw new Error("The parameter 'postingAccountId' cannot be null.");
        else if (request.postingAccountId !== undefined)
            url_ += "PostingAccountId=" + encodeURIComponent("" + request.postingAccountId) + "&";
        if (request.loadCarrierTypeId === null)
            throw new Error("The parameter 'loadCarrierTypeId' cannot be null.");
        else if (request.loadCarrierTypeId !== undefined)
            url_ += "LoadCarrierTypeId=" + encodeURIComponent("" + request.loadCarrierTypeId) + "&";
        if (request.refLtmsArticleId === null)
            throw new Error("The parameter 'refLtmsArticleId' cannot be null.");
        else if (request.refLtmsArticleId !== undefined)
            url_ += "RefLtmsArticleId=" + encodeURIComponent("" + request.refLtmsArticleId) + "&";
        if (request.forceBalanceCalculation === null)
            throw new Error("The parameter 'forceBalanceCalculation' cannot be null.");
        else if (request.forceBalanceCalculation !== undefined)
            url_ += "ForceBalanceCalculation=" + encodeURIComponent("" + request.forceBalanceCalculation) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<BalancesSummary>><any>_observableThrow(e);
                }
            } else
                return <Observable<BalancesSummary>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<BalancesSummary> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BalancesSummary>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BalancesSummary>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PostingAccountsAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getLtmsAccountsByCustomerNumber(number: string | null): Observable<LtmsAccount[]> {
        let url_ = this.baseUrl + "/postingaccountsadministration/ref-accounts/{number}";
        if (number === undefined || number === null)
            throw new Error("The parameter 'number' must be defined.");
        url_ = url_.replace("{number}", encodeURIComponent("" + number));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLtmsAccountsByCustomerNumber(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLtmsAccountsByCustomerNumber(<any>response_);
                } catch (e) {
                    return <Observable<LtmsAccount[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LtmsAccount[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLtmsAccountsByCustomerNumber(response: HttpResponseBase): Observable<LtmsAccount[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LtmsAccount[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LtmsAccount[]>(<any>null);
    }

    getByCustomerId(id: number): Observable<PostingAccountAdministration[]> {
        let url_ = this.baseUrl + "/postingaccountsadministration/customer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByCustomerId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByCustomerId(<any>response_);
                } catch (e) {
                    return <Observable<PostingAccountAdministration[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingAccountAdministration[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetByCustomerId(response: HttpResponseBase): Observable<PostingAccountAdministration[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostingAccountAdministration[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getById(id: number): Observable<PostingAccountAdministration> {
        let url_ = this.baseUrl + "/postingaccountsadministration/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PostingAccountAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingAccountAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PostingAccountAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostingAccountAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		postingAccountId?: number | null | undefined,
		customerId?: number | null | undefined,
	}): Observable<LoadResult> {
        let url_ = this.baseUrl + "/postingaccountsadministration?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.postingAccountId !== undefined && request.postingAccountId !== null)
            url_ += "PostingAccountId=" + encodeURIComponent("" + request.postingAccountId) + "&";
        if (request.customerId !== undefined && request.customerId !== null)
            url_ += "CustomerId=" + encodeURIComponent("" + request.customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadResult>(<any>null);
    }

    post(values?: string | null | undefined): Observable<PostingAccountAdministration> {
        let url_ = this.baseUrl + "/postingaccountsadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<PostingAccountAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingAccountAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<PostingAccountAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <PostingAccountAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(key?: number | undefined, values?: string | null | undefined): Observable<PostingAccountAdministration> {
        let url_ = this.baseUrl + "/postingaccountsadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (key === null || key === undefined)
            throw new Error("The parameter 'key' cannot be null.");
        else
            content_.append("key", key.toString());
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<PostingAccountAdministration>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingAccountAdministration>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<PostingAccountAdministration> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostingAccountAdministration>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostingAccountAdministration>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PostingAccountsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Observable<PostingAccount[]> {
        let url_ = this.baseUrl + "/postingaccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PostingAccount[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingAccount[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PostingAccount[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostingAccount[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostingAccount[]>(<any>null);
    }

    getBalances(id: number): Observable<Balance[]> {
        let url_ = this.baseUrl + "/postingaccounts/{id}/balances";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalances(<any>response_);
                } catch (e) {
                    return <Observable<Balance[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Balance[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBalances(response: HttpResponseBase): Observable<Balance[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Balance[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getAllowedDestinationAccounts(): Observable<AllowedPostingAccount[]> {
        let url_ = this.baseUrl + "/postingaccounts/alloweddestinationaccounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllowedDestinationAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllowedDestinationAccounts(<any>response_);
                } catch (e) {
                    return <Observable<AllowedPostingAccount[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AllowedPostingAccount[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllowedDestinationAccounts(response: HttpResponseBase): Observable<AllowedPostingAccount[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AllowedPostingAccount[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AllowedPostingAccount[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class PostingRequestsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		postingAccountId?: number | undefined,
		loadCarrierTypeId?: number | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<LoadResult> {
        let url_ = this.baseUrl + "/postingrequests?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.postingAccountId === null)
            throw new Error("The parameter 'postingAccountId' cannot be null.");
        else if (request.postingAccountId !== undefined)
            url_ += "PostingAccountId=" + encodeURIComponent("" + request.postingAccountId) + "&";
        if (request.loadCarrierTypeId === null)
            throw new Error("The parameter 'loadCarrierTypeId' cannot be null.");
        else if (request.loadCarrierTypeId !== undefined)
            url_ += "LoadCarrierTypeId=" + encodeURIComponent("" + request.loadCarrierTypeId) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<LoadResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoadResult>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<LoadResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LoadResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoadResult>(<any>null);
    }

    post(request: PostingRequestsCreateRequest): Observable<PostingRequest[]> {
        let url_ = this.baseUrl + "/postingrequests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<PostingRequest[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingRequest[]>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<PostingRequest[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <PostingRequest[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    getById(id: number): Observable<PostingRequest> {
        let url_ = this.baseUrl + "/postingrequests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<PostingRequest>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingRequest>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<PostingRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostingRequest>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patch(id: number, request: PostingRequestsUpdateRequest): Observable<PostingRequest> {
        let url_ = this.baseUrl + "/postingrequests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<PostingRequest>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingRequest>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<PostingRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostingRequest>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patchPostingRequestCancelled(id: number): Observable<PostingRequest> {
        let url_ = this.baseUrl + "/postingrequests/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchPostingRequestCancelled(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchPostingRequestCancelled(<any>response_);
                } catch (e) {
                    return <Observable<PostingRequest>><any>_observableThrow(e);
                }
            } else
                return <Observable<PostingRequest>><any>_observableThrow(response_);
        }));
    }

    protected processPatchPostingRequestCancelled(response: HttpResponseBase): Observable<PostingRequest> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PostingRequest>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PostingRequest>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ReportingApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    postReportDesignerModel(reportUrl?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/reporting/designer-model";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (reportUrl !== null && reportUrl !== undefined)
            content_.append("ReportUrl", reportUrl.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostReportDesignerModel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostReportDesignerModel(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPostReportDesignerModel(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class UploadsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		customerName?: string | null | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<IPaginationResultOfUpload> {
        let url_ = this.baseUrl + "/uploads?";
        if (request.customerName !== undefined && request.customerName !== null)
            url_ += "CustomerName=" + encodeURIComponent("" + request.customerName) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfUpload>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfUpload>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IPaginationResultOfUpload> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfUpload>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfUpload>(<any>null);
    }

    post(request: CreateUploadRequest): Observable<Upload> {
        let url_ = this.baseUrl + "/uploads";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<Upload>><any>_observableThrow(e);
                }
            } else
                return <Observable<Upload>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<Upload> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Upload>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getById(id: number): Observable<Upload> {
        let url_ = this.baseUrl + "/uploads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<Upload>><any>_observableThrow(e);
                }
            } else
                return <Observable<Upload>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Upload> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Upload>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patch(id: number, request: UpdateUploadRequest): Observable<Upload> {
        let url_ = this.baseUrl + "/uploads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<Upload>><any>_observableThrow(e);
                }
            } else
                return <Observable<Upload>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<Upload> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Upload>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    delete(id: number): Observable<void> {
        let url_ = this.baseUrl + "/uploads/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    getBalances(id: number): Observable<string[]> {
        let url_ = this.baseUrl + "/uploads/{id}/balances";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalances(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBalances(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    post(values?: string | null | undefined): Observable<UserListItem> {
        let url_ = this.baseUrl + "/useradministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<UserListItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListItem>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<UserListItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <UserListItem>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    put(key?: number | undefined, values?: string | null | undefined): Observable<UserListItem> {
        let url_ = this.baseUrl + "/useradministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (key === null || key === undefined)
            throw new Error("The parameter 'key' cannot be null.");
        else
            content_.append("key", key.toString());
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<UserListItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListItem>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<UserListItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserListItem>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListItem>(<any>null);
    }

    get(request: {
		customerId?: number | null | undefined,
		organizationId?: number | null | undefined,
		divisionId?: number | null | undefined,
		loadOptions?: DataSourceLoadOptions | null | undefined,
	}): Observable<FileResponse> {
        let url_ = this.baseUrl + "/useradministration?";
        if (request.customerId !== undefined && request.customerId !== null)
            url_ += "CustomerId=" + encodeURIComponent("" + request.customerId) + "&";
        if (request.organizationId !== undefined && request.organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + request.organizationId) + "&";
        if (request.divisionId !== undefined && request.divisionId !== null)
            url_ += "DivisionId=" + encodeURIComponent("" + request.divisionId) + "&";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    all(request: {
		customerId?: number | null | undefined,
		organizationId?: number | null | undefined,
		divisionId?: number | null | undefined,
	}): Observable<UserListItem[]> {
        let url_ = this.baseUrl + "/useradministration/all?";
        if (request.customerId !== undefined && request.customerId !== null)
            url_ += "CustomerId=" + encodeURIComponent("" + request.customerId) + "&";
        if (request.organizationId !== undefined && request.organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + request.organizationId) + "&";
        if (request.divisionId !== undefined && request.divisionId !== null)
            url_ += "DivisionId=" + encodeURIComponent("" + request.divisionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAll(<any>response_);
                } catch (e) {
                    return <Observable<UserListItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processAll(response: HttpResponseBase): Observable<UserListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserListItem[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListItem[]>(<any>null);
    }

    allByOrganization(request: {
		organizationId?: number | undefined,
		exceptCustomerId?: number | null | undefined,
	}): Observable<UserListItem[]> {
        let url_ = this.baseUrl + "/useradministration/allbyorganization?";
        if (request.organizationId === null)
            throw new Error("The parameter 'organizationId' cannot be null.");
        else if (request.organizationId !== undefined)
            url_ += "OrganizationId=" + encodeURIComponent("" + request.organizationId) + "&";
        if (request.exceptCustomerId !== undefined && request.exceptCustomerId !== null)
            url_ += "ExceptCustomerId=" + encodeURIComponent("" + request.exceptCustomerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAllByOrganization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAllByOrganization(<any>response_);
                } catch (e) {
                    return <Observable<UserListItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserListItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processAllByOrganization(response: HttpResponseBase): Observable<UserListItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserListItem[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserListItem[]>(<any>null);
    }

    patchLocked(id: number, locked: boolean): Observable<User> {
        let url_ = this.baseUrl + "/useradministration/{id}/patchlocked";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(locked);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchLocked(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchLocked(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processPatchLocked(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    addToCustomer(id: number, customerId: number): Observable<User> {
        let url_ = this.baseUrl + "/useradministration/{id}/addtocustomer";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(customerId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToCustomer(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processAddToCustomer(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    removeFromCustomer(id: number, customerId: number): Observable<User> {
        let url_ = this.baseUrl + "/useradministration/{id}/removefromcustomer";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(customerId);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFromCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFromCustomer(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveFromCustomer(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    postResetPassword(id: number): Observable<UserResetPasswordResult> {
        let url_ = this.baseUrl + "/useradministration/{id}/reset-password";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<UserResetPasswordResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserResetPasswordResult>><any>_observableThrow(response_);
        }));
    }

    protected processPostResetPassword(response: HttpResponseBase): Observable<UserResetPasswordResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <UserResetPasswordResult>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		customerId?: number | null | undefined,
	}): Observable<User> {
        let url_ = this.baseUrl + "/user?";
        if (request.customerId !== undefined && request.customerId !== null)
            url_ += "customerId=" + encodeURIComponent("" + request.customerId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <User>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    updateSettings(settings: any): Observable<FileResponse> {
        let url_ = this.baseUrl + "/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSettings(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSettings(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class UserGroupAdministrationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    post(values?: string | null | undefined): Observable<UserGroupListItem> {
        let url_ = this.baseUrl + "/usergroupadministration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<UserGroupListItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserGroupListItem>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<UserGroupListItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <UserGroupListItem>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    get(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		customerId?: number | null | undefined,
		organizationId?: number | null | undefined,
		customerDivisionId?: number | null | undefined,
		postingAccountId?: number | null | undefined,
	}): Observable<FileResponse> {
        let url_ = this.baseUrl + "/usergroupadministration?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.customerId !== undefined && request.customerId !== null)
            url_ += "CustomerId=" + encodeURIComponent("" + request.customerId) + "&";
        if (request.organizationId !== undefined && request.organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + request.organizationId) + "&";
        if (request.customerDivisionId !== undefined && request.customerDivisionId !== null)
            url_ += "CustomerDivisionId=" + encodeURIComponent("" + request.customerDivisionId) + "&";
        if (request.postingAccountId !== undefined && request.postingAccountId !== null)
            url_ += "PostingAccountId=" + encodeURIComponent("" + request.postingAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    members(request: {
		loadOptions?: DataSourceLoadOptions | null | undefined,
		customerId?: number | null | undefined,
		organizationId?: number | null | undefined,
		customerDivisionId?: number | null | undefined,
		postingAccountId?: number | null | undefined,
	}): Observable<FileResponse> {
        let url_ = this.baseUrl + "/usergroupadministration/members?";
        if (request.loadOptions !== undefined && request.loadOptions !== null)
            url_ += "loadOptions=" + encodeURIComponent("" + request.loadOptions) + "&";
        if (request.customerId !== undefined && request.customerId !== null)
            url_ += "CustomerId=" + encodeURIComponent("" + request.customerId) + "&";
        if (request.organizationId !== undefined && request.organizationId !== null)
            url_ += "OrganizationId=" + encodeURIComponent("" + request.organizationId) + "&";
        if (request.customerDivisionId !== undefined && request.customerDivisionId !== null)
            url_ += "CustomerDivisionId=" + encodeURIComponent("" + request.customerDivisionId) + "&";
        if (request.postingAccountId !== undefined && request.postingAccountId !== null)
            url_ += "PostingAccountId=" + encodeURIComponent("" + request.postingAccountId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMembers(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processMembers(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    putPermissions(key?: number | undefined, values?: string | null | undefined): Observable<UserGroupListItem> {
        let url_ = this.baseUrl + "/usergroupadministration/updatepermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (key === null || key === undefined)
            throw new Error("The parameter 'key' cannot be null.");
        else
            content_.append("key", key.toString());
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPutPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutPermissions(<any>response_);
                } catch (e) {
                    return <Observable<UserGroupListItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserGroupListItem>><any>_observableThrow(response_);
        }));
    }

    protected processPutPermissions(response: HttpResponseBase): Observable<UserGroupListItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserGroupListItem>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserGroupListItem>(<any>null);
    }

    patchMembers(key?: number | undefined, values?: string | null | undefined): Observable<UserGroupListItem> {
        let url_ = this.baseUrl + "/usergroupadministration/updatemembers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (key === null || key === undefined)
            throw new Error("The parameter 'key' cannot be null.");
        else
            content_.append("key", key.toString());
        if (values !== null && values !== undefined)
            content_.append("values", values.toString());

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchMembers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchMembers(<any>response_);
                } catch (e) {
                    return <Observable<UserGroupListItem>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserGroupListItem>><any>_observableThrow(response_);
        }));
    }

    protected processPatchMembers(response: HttpResponseBase): Observable<UserGroupListItem> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserGroupListItem>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserGroupListItem>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class VouchersApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		customerId?: number[] | null | undefined,
		type?: VoucherType | null | undefined,
		documentNumber?: string | null | undefined,
		recipient?: string | null | undefined,
		recipientType?: PartnerType | null | undefined,
		toIssueDate?: Date | null | undefined,
		fromIssueDate?: Date | null | undefined,
		states?: VoucherStatus[] | null | undefined,
		reasonTypes?: number[] | null | undefined,
		loadCarrierTypes?: number[] | null | undefined,
		shipper?: string | null | undefined,
		subShipper?: string | null | undefined,
		validFrom?: Date | null | undefined,
		validTo?: Date | null | undefined,
		quantityFrom?: number | null | undefined,
		quantityTo?: number | null | undefined,
		supplier?: string | null | undefined,
		procurementLogistics?: boolean | undefined,
		customerReference?: string | null | undefined,
		hasDplNote?: boolean | null | undefined,
		sortBy?: VouchersSearchRequestSortOptions | undefined,
		sortDirection?: ListSortDirection | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<IPaginationResultOfVoucher> {
        let url_ = this.baseUrl + "/vouchers?";
        if (request.customerId !== undefined && request.customerId !== null)
            request.customerId && request.customerId.forEach(item => { url_ += "CustomerId=" + encodeURIComponent("" + item) + "&"; });
        if (request.type !== undefined && request.type !== null)
            url_ += "Type=" + encodeURIComponent("" + request.type) + "&";
        if (request.documentNumber !== undefined && request.documentNumber !== null)
            url_ += "DocumentNumber=" + encodeURIComponent("" + request.documentNumber) + "&";
        if (request.recipient !== undefined && request.recipient !== null)
            url_ += "Recipient=" + encodeURIComponent("" + request.recipient) + "&";
        if (request.recipientType !== undefined && request.recipientType !== null)
            url_ += "RecipientType=" + encodeURIComponent("" + request.recipientType) + "&";
        if (request.toIssueDate !== undefined && request.toIssueDate !== null)
            url_ += "ToIssueDate=" + encodeURIComponent(request.toIssueDate ? "" + request.toIssueDate.toJSON() : "") + "&";
        if (request.fromIssueDate !== undefined && request.fromIssueDate !== null)
            url_ += "FromIssueDate=" + encodeURIComponent(request.fromIssueDate ? "" + request.fromIssueDate.toJSON() : "") + "&";
        if (request.states !== undefined && request.states !== null)
            request.states && request.states.forEach(item => { url_ += "States=" + encodeURIComponent("" + item) + "&"; });
        if (request.reasonTypes !== undefined && request.reasonTypes !== null)
            request.reasonTypes && request.reasonTypes.forEach(item => { url_ += "ReasonTypes=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierTypes !== undefined && request.loadCarrierTypes !== null)
            request.loadCarrierTypes && request.loadCarrierTypes.forEach(item => { url_ += "LoadCarrierTypes=" + encodeURIComponent("" + item) + "&"; });
        if (request.shipper !== undefined && request.shipper !== null)
            url_ += "Shipper=" + encodeURIComponent("" + request.shipper) + "&";
        if (request.subShipper !== undefined && request.subShipper !== null)
            url_ += "SubShipper=" + encodeURIComponent("" + request.subShipper) + "&";
        if (request.validFrom !== undefined && request.validFrom !== null)
            url_ += "ValidFrom=" + encodeURIComponent(request.validFrom ? "" + request.validFrom.toJSON() : "") + "&";
        if (request.validTo !== undefined && request.validTo !== null)
            url_ += "ValidTo=" + encodeURIComponent(request.validTo ? "" + request.validTo.toJSON() : "") + "&";
        if (request.quantityFrom !== undefined && request.quantityFrom !== null)
            url_ += "QuantityFrom=" + encodeURIComponent("" + request.quantityFrom) + "&";
        if (request.quantityTo !== undefined && request.quantityTo !== null)
            url_ += "QuantityTo=" + encodeURIComponent("" + request.quantityTo) + "&";
        if (request.supplier !== undefined && request.supplier !== null)
            url_ += "Supplier=" + encodeURIComponent("" + request.supplier) + "&";
        if (request.procurementLogistics === null)
            throw new Error("The parameter 'procurementLogistics' cannot be null.");
        else if (request.procurementLogistics !== undefined)
            url_ += "ProcurementLogistics=" + encodeURIComponent("" + request.procurementLogistics) + "&";
        if (request.customerReference !== undefined && request.customerReference !== null)
            url_ += "CustomerReference=" + encodeURIComponent("" + request.customerReference) + "&";
        if (request.hasDplNote !== undefined && request.hasDplNote !== null)
            url_ += "HasDplNote=" + encodeURIComponent("" + request.hasDplNote) + "&";
        if (request.sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (request.sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + request.sortBy) + "&";
        if (request.sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (request.sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + request.sortDirection) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<IPaginationResultOfVoucher>><any>_observableThrow(e);
                }
            } else
                return <Observable<IPaginationResultOfVoucher>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<IPaginationResultOfVoucher> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IPaginationResultOfVoucher>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IPaginationResultOfVoucher>(<any>null);
    }

    post(request: VouchersCreateRequest): Observable<Voucher> {
        let url_ = this.baseUrl + "/vouchers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<Voucher>><any>_observableThrow(e);
                }
            } else
                return <Observable<Voucher>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<Voucher> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            result201 = _responseText === "" ? null : <Voucher>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result201);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 500) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result500: any = null;
            result500 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    /**
     * @deprecated
     */
    getById(id: number): Observable<Voucher> {
        let url_ = this.baseUrl + "/vouchers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<Voucher>><any>_observableThrow(e);
                }
            } else
                return <Observable<Voucher>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<Voucher> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Voucher>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patch(id: number, request: VouchersAddToSubmissionRequest): Observable<Voucher> {
        let url_ = this.baseUrl + "/vouchers/{id}/submit";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch(<any>response_);
                } catch (e) {
                    return <Observable<Voucher>><any>_observableThrow(e);
                }
            } else
                return <Observable<Voucher>><any>_observableThrow(response_);
        }));
    }

    protected processPatch(response: HttpResponseBase): Observable<Voucher> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Voucher>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patch2(id: number, request: VouchersRemoveFromSubmissionRequest): Observable<Voucher> {
        let url_ = this.baseUrl + "/vouchers/{id}/remove";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatch2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatch2(<any>response_);
                } catch (e) {
                    return <Observable<Voucher>><any>_observableThrow(e);
                }
            } else
                return <Observable<Voucher>><any>_observableThrow(response_);
        }));
    }

    protected processPatch2(response: HttpResponseBase): Observable<Voucher> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Voucher>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }

    patchVoucherCancel(id: number, request: VouchersCancelRequest): Observable<Voucher> {
        let url_ = this.baseUrl + "/vouchers/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPatchVoucherCancel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPatchVoucherCancel(<any>response_);
                } catch (e) {
                    return <Observable<Voucher>><any>_observableThrow(e);
                }
            } else
                return <Observable<Voucher>><any>_observableThrow(response_);
        }));
    }

    protected processPatchVoucherCancel(response: HttpResponseBase): Observable<Voucher> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Voucher>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result404: any = null;
            result404 = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            result400 = _responseText === "" ? null : <DplProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let resultdefault: any = null;
            resultdefault = _responseText === "" ? null : <ProblemDetails>JSON.parse(_responseText, this.jsonParseReviver);
            return throwException("A server side error occurred.", status, _responseText, _headers, resultdefault);
            }));
        }
    }
}

@Injectable({
    providedIn: 'root'
})
export class VouchersSummariesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(request: {
		customerId?: number[] | null | undefined,
		type?: VoucherType | null | undefined,
		documentNumber?: string | null | undefined,
		recipient?: string | null | undefined,
		recipientType?: PartnerType | null | undefined,
		toIssueDate?: Date | null | undefined,
		fromIssueDate?: Date | null | undefined,
		states?: VoucherStatus[] | null | undefined,
		reasonTypes?: number[] | null | undefined,
		loadCarrierTypes?: number[] | null | undefined,
		shipper?: string | null | undefined,
		subShipper?: string | null | undefined,
		validFrom?: Date | null | undefined,
		validTo?: Date | null | undefined,
		quantityFrom?: number | null | undefined,
		quantityTo?: number | null | undefined,
		supplier?: string | null | undefined,
		procurementLogistics?: boolean | undefined,
		customerReference?: string | null | undefined,
		hasDplNote?: boolean | null | undefined,
		sortBy?: VouchersSearchRequestSortOptions | undefined,
		sortDirection?: ListSortDirection | undefined,
		page?: number | undefined,
		limit?: number | undefined,
	}): Observable<VoucherSummary[]> {
        let url_ = this.baseUrl + "/voucherssummaries?";
        if (request.customerId !== undefined && request.customerId !== null)
            request.customerId && request.customerId.forEach(item => { url_ += "CustomerId=" + encodeURIComponent("" + item) + "&"; });
        if (request.type !== undefined && request.type !== null)
            url_ += "Type=" + encodeURIComponent("" + request.type) + "&";
        if (request.documentNumber !== undefined && request.documentNumber !== null)
            url_ += "DocumentNumber=" + encodeURIComponent("" + request.documentNumber) + "&";
        if (request.recipient !== undefined && request.recipient !== null)
            url_ += "Recipient=" + encodeURIComponent("" + request.recipient) + "&";
        if (request.recipientType !== undefined && request.recipientType !== null)
            url_ += "RecipientType=" + encodeURIComponent("" + request.recipientType) + "&";
        if (request.toIssueDate !== undefined && request.toIssueDate !== null)
            url_ += "ToIssueDate=" + encodeURIComponent(request.toIssueDate ? "" + request.toIssueDate.toJSON() : "") + "&";
        if (request.fromIssueDate !== undefined && request.fromIssueDate !== null)
            url_ += "FromIssueDate=" + encodeURIComponent(request.fromIssueDate ? "" + request.fromIssueDate.toJSON() : "") + "&";
        if (request.states !== undefined && request.states !== null)
            request.states && request.states.forEach(item => { url_ += "States=" + encodeURIComponent("" + item) + "&"; });
        if (request.reasonTypes !== undefined && request.reasonTypes !== null)
            request.reasonTypes && request.reasonTypes.forEach(item => { url_ += "ReasonTypes=" + encodeURIComponent("" + item) + "&"; });
        if (request.loadCarrierTypes !== undefined && request.loadCarrierTypes !== null)
            request.loadCarrierTypes && request.loadCarrierTypes.forEach(item => { url_ += "LoadCarrierTypes=" + encodeURIComponent("" + item) + "&"; });
        if (request.shipper !== undefined && request.shipper !== null)
            url_ += "Shipper=" + encodeURIComponent("" + request.shipper) + "&";
        if (request.subShipper !== undefined && request.subShipper !== null)
            url_ += "SubShipper=" + encodeURIComponent("" + request.subShipper) + "&";
        if (request.validFrom !== undefined && request.validFrom !== null)
            url_ += "ValidFrom=" + encodeURIComponent(request.validFrom ? "" + request.validFrom.toJSON() : "") + "&";
        if (request.validTo !== undefined && request.validTo !== null)
            url_ += "ValidTo=" + encodeURIComponent(request.validTo ? "" + request.validTo.toJSON() : "") + "&";
        if (request.quantityFrom !== undefined && request.quantityFrom !== null)
            url_ += "QuantityFrom=" + encodeURIComponent("" + request.quantityFrom) + "&";
        if (request.quantityTo !== undefined && request.quantityTo !== null)
            url_ += "QuantityTo=" + encodeURIComponent("" + request.quantityTo) + "&";
        if (request.supplier !== undefined && request.supplier !== null)
            url_ += "Supplier=" + encodeURIComponent("" + request.supplier) + "&";
        if (request.procurementLogistics === null)
            throw new Error("The parameter 'procurementLogistics' cannot be null.");
        else if (request.procurementLogistics !== undefined)
            url_ += "ProcurementLogistics=" + encodeURIComponent("" + request.procurementLogistics) + "&";
        if (request.customerReference !== undefined && request.customerReference !== null)
            url_ += "CustomerReference=" + encodeURIComponent("" + request.customerReference) + "&";
        if (request.hasDplNote !== undefined && request.hasDplNote !== null)
            url_ += "HasDplNote=" + encodeURIComponent("" + request.hasDplNote) + "&";
        if (request.sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (request.sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + request.sortBy) + "&";
        if (request.sortDirection === null)
            throw new Error("The parameter 'sortDirection' cannot be null.");
        else if (request.sortDirection !== undefined)
            url_ += "SortDirection=" + encodeURIComponent("" + request.sortDirection) + "&";
        if (request.page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (request.page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + request.page) + "&";
        if (request.limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (request.limit !== undefined)
            url_ += "Limit=" + encodeURIComponent("" + request.limit) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<VoucherSummary[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<VoucherSummary[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<VoucherSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <VoucherSummary[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<VoucherSummary[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class WebDocumentViewerApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    invoke(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/dxxrdv";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoke(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processInvoke(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    invoke2(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/dxxrdv";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoke2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoke2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processInvoke2(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    invoke3(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/dxxrdv";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("options", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoke3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoke3(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processInvoke3(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getLocalization(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/dxxrdv/getlocalization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalization(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocalization(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ReportDesignerApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    invoke(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/dxxrd";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoke(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processInvoke(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getLocalization(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/dxxrd/getlocalization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalization(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocalization(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class QueryBuilderApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    invoke(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/dxxqb";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInvoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInvoke(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processInvoke(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getLocalization(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/dxxqb/getlocalization";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocalization(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocalization(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocalization(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface LoadResult {
    data?: IEnumerable | null;
    totalCount?: number;
    groupCount?: number;
    summary?: any[] | null;
}

export interface IEnumerable {
}

export interface DataSourceLoadOptionsBase {
    requireTotalCount?: boolean;
    requireGroupCount?: boolean;
    isCountQuery?: boolean;
    skip?: number;
    take?: number;
    sort?: SortingInfo[] | null;
    group?: GroupingInfo[] | null;
    filter?: any[] | null;
    totalSummary?: SummaryInfo[] | null;
    groupSummary?: SummaryInfo[] | null;
    select?: string[] | null;
    preSelect?: string[] | null;
    remoteSelect?: boolean | null;
    remoteGrouping?: boolean | null;
    expandLinqSumType?: boolean | null;
    primaryKey?: string[] | null;
    defaultSort?: string | null;
    stringToLower?: boolean | null;
    paginateViaPrimaryKey?: boolean | null;
    sortByPrimaryKey?: boolean | null;
    allowAsyncOverSync?: boolean;
}

export interface DataSourceLoadOptions extends DataSourceLoadOptionsBase {
}

export interface SortingInfo {
    selector?: string | null;
    desc?: boolean;
}

export interface GroupingInfo extends SortingInfo {
    groupInterval?: string | null;
    isExpanded?: boolean | null;
}

export interface SummaryInfo {
    selector?: string | null;
    summaryType?: string | null;
}

export enum AccountingRecordStatus {
    Provisional = "Provisional",
    Uncoordinated = "Uncoordinated",
    InCoordination = "InCoordination",
    Coordinated = "Coordinated",
    Pending = "Pending",
    Canceled = "Canceled",
}

export interface AccountingRecord {
    id?: number;
    transactionId?: string;
    processId?: number;
    referenceNumber?: string | null;
    postingAccountId?: number;
    type?: string | null;
    status?: string | null;
    loadCarrierTypeName?: string | null;
    qualityName?: string | null;
    date?: Date;
    extDescription?: string | null;
    loadCarrierId?: number;
    quantity?: number | null;
    charge?: number | null;
    credit?: number | null;
    createTime?: Date;
    updateTime?: Date | null;
    dplNote?: EmployeeNote | null;
    hasDplNote?: boolean;
}

export interface EmployeeNote {
    id?: number;
    type?: EmployeeNoteType;
    reason?: EmployeeNoteReason;
    createdAt?: Date;
    contact?: string | null;
    contactedAt?: Date;
    text?: string | null;
}

export enum EmployeeNoteType {
    Create = "Create",
    Updated = "Updated",
    Cancellation = "Cancellation",
    CancellationConfirmed = "CancellationConfirmed",
}

export enum EmployeeNoteReason {
    Mail = "Mail",
    Phone = "Phone",
    Fax = "Fax",
    Other = "Other",
}

export interface ProblemDetails {
    type?: string | null;
    title?: string | null;
    status?: number | null;
    detail?: string | null;
    instance?: string | null;
    extensions?: { [key: string]: any; } | null;
}

export interface Country {
    id?: number;
    name?: string | null;
    licensePlateCode?: string | null;
    iso2Code?: string | null;
    iso3Code?: string | null;
    states?: CountryState[] | null;
}

export interface CountryState {
    id?: number;
    name?: string | null;
}

export interface Address {
    id?: number;
    street1?: string | null;
    street2?: string | null;
    postalCode?: string | null;
    city?: string | null;
    stateName?: string | null;
    countryName?: string | null;
    state?: number | null;
    country?: number | null;
}

export interface AddressAdministration extends Address {
    geoLocation?: Point | null;
}

export interface Geometry {
    factory?: GeometryFactory | null;
    userData?: any | null;
    srid?: number;
    precisionModel?: PrecisionModel | null;
    numGeometries?: number;
    isSimple?: boolean;
    isValid?: boolean;
    area?: number;
    length?: number;
    centroid?: Point | null;
    interiorPoint?: Point | null;
    pointOnSurface?: Point | null;
    envelope?: Geometry | null;
    envelopeInternal?: Envelope | null;
    isRectangle?: boolean;
}

export interface Point extends Geometry {
    coordinateSequence?: CoordinateSequence | null;
    coordinates?: Coordinate[] | null;
    numPoints?: number;
    isEmpty?: boolean;
    dimension?: Dimension;
    boundaryDimension?: Dimension;
    x?: number;
    y?: number;
    coordinate?: Coordinate | null;
    geometryType?: string | null;
    ogcGeometryType?: OgcGeometryType;
    boundary?: Geometry | null;
    z?: number;
    m?: number;
}

export interface CoordinateSequence {
    dimension?: number;
    measures?: number;
    spatial?: number;
    ordinates?: Ordinates;
    hasZ?: boolean;
    hasM?: boolean;
    zOrdinateIndex?: number;
    mOrdinateIndex?: number;
    count?: number;
}

export enum Ordinates {
    None = "None",
    X = "Spatial1",
    Spatial1 = "Spatial1",
    Y = "Spatial2",
    Spatial2 = "Spatial2",
    XY = "XY",
    Spatial3 = "Z",
    Z = "Z",
    XYZ = "XYZ",
    Spatial4 = "Spatial4",
    Spatial5 = "Spatial5",
    Spatial6 = "Spatial6",
    Spatial7 = "Spatial7",
    Spatial8 = "Spatial8",
    Spatial9 = "Spatial9",
    Spatial10 = "Spatial10",
    Spatial11 = "Spatial11",
    Spatial12 = "Spatial12",
    Spatial13 = "Spatial13",
    Spatial14 = "Spatial14",
    Spatial15 = "Spatial15",
    Spatial16 = "Spatial16",
    AllSpatialOrdinates = "AllSpatialOrdinates",
    Measure1 = "M",
    M = "M",
    XYM = "XYM",
    XYZM = "XYZM",
    Measure2 = "Measure2",
    Measure3 = "Measure3",
    Measure4 = "Measure4",
    Measure5 = "Measure5",
    Measure6 = "Measure6",
    Measure7 = "Measure7",
    Measure8 = "Measure8",
    Measure9 = "Measure9",
    Measure10 = "Measure10",
    Measure11 = "Measure11",
    Measure12 = "Measure12",
    Measure13 = "Measure13",
    Measure14 = "Measure14",
    Measure15 = "Measure15",
    Measure16 = "Measure16",
    AllMeasureOrdinates = "AllMeasureOrdinates",
    AllOrdinates = "AllOrdinates",
}

export interface Coordinate {
    x?: number;
    y?: number;
    z?: number;
    m?: number;
    coordinateValue?: Coordinate | null;
}

export enum Dimension {
    Point = "Point",
    Curve = "Curve",
    Surface = "Surface",
    Dontcare = "Dontcare",
    True = "True",
    False = "False",
}

export enum OgcGeometryType {
    Point = "Point",
    LineString = "LineString",
    Polygon = "Polygon",
    MultiPoint = "MultiPoint",
    MultiLineString = "MultiLineString",
    MultiPolygon = "MultiPolygon",
    GeometryCollection = "GeometryCollection",
    CircularString = "CircularString",
    CompoundCurve = "CompoundCurve",
    CurvePolygon = "CurvePolygon",
    MultiCurve = "MultiCurve",
    MultiSurface = "MultiSurface",
    Curve = "Curve",
    Surface = "Surface",
    PolyhedralSurface = "PolyhedralSurface",
    TIN = "TIN",
}

export interface GeometryFactory {
    precisionModel?: PrecisionModel | null;
    coordinateSequenceFactory?: CoordinateSequenceFactory | null;
    srid?: number;
}

export interface PrecisionModel {
    isFloating?: boolean;
    maximumSignificantDigits?: number;
    scale?: number;
    precisionModelType?: PrecisionModels;
}

export enum PrecisionModels {
    Floating = "Floating",
    FloatingSingle = "FloatingSingle",
    Fixed = "Fixed",
}

export interface CoordinateSequenceFactory {
    ordinates?: Ordinates;
}

export interface Envelope {
    isNull?: boolean;
    width?: number;
    height?: number;
    minX?: number;
    maxX?: number;
    minY?: number;
    maxY?: number;
    area?: number;
    minExtent?: number;
    maxExtent?: number;
    centre?: Coordinate | null;
}

export interface ValidationProblemDetails extends ProblemDetails {
    errors?: { [key: string]: string[]; } | null;
}

export interface DplProblemDetails extends ValidationProblemDetails {
    ruleStates?: StateItem[][] | null;
    serviceStates?: StateItem[][] | null;
}

export interface StateItem {
    type?: StateItemType;
    messageId?: string | null;
}

export enum StateItemType {
    Warning = "Warning",
    Error = "Error",
}

export interface IPaginationResultOfBalanceTransfer {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: BalanceTransfer[] | null;
}

export interface BalanceTransfer {
    id?: number;
    status?: BalanceTransferStatus;
    sourceAccountId?: number;
    destinationAccountId?: number;
    loadCarrierId?: number;
    quantity?: number;
}

export enum BalanceTransferStatus {
    Pending = "Pending",
    Completed = "Completed",
}

export interface PostingRequest {
    id?: number;
    referenceNumber?: string | null;
    postingAccountId?: number;
    loadCarrierId?: number;
    reason?: PostingRequestReason;
    type?: PostingRequestType;
    status?: PostingRequestStatus;
    isSortingRequired?: boolean;
    loadCarrierQuantity?: number;
    voucherId?: number | null;
    submissionId?: number | null;
    orderMatchId?: number | null;
    note?: string | null;
    refLtmsTransactionId?: string;
}

export enum PostingRequestReason {
    Transfer = "Transfer",
    Voucher = "Voucher",
    LoadCarrierReceipt = "LoadCarrierReceipt",
    Sorting = "Sorting",
}

export enum PostingRequestType {
    Credit = "Credit",
    Charge = "Charge",
}

export enum PostingRequestStatus {
    Pending = "Pending",
    Confirmed = "Confirmed",
    Canceled = "Canceled",
}

export interface BalanceTransferCreateRequest {
    digitalCode?: string | null;
    sourceAccountId?: number | null;
    destinationAccountId?: number | null;
    loadCarrierId?: number | null;
    quantity?: number | null;
    note?: string | null;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface EmployeeNoteCreateRequest {
    type?: EmployeeNoteType;
    reason?: EmployeeNoteReason;
    contact?: string | null;
    contactedAt?: Date;
    text?: string | null;
}

export interface BalanceTransferCancelRequest {
    reason?: string | null;
}

export interface ChatUser {
    userName?: string | null;
    email?: string | null;
    language?: string | null;
    token?: string | null;
}

export interface CustomerDivision {
    id?: number;
    name?: string | null;
    shortName?: string | null;
    postingAccountId?: number | null;
    defaultLoadingLocationId?: number | null;
    customerId?: number;
    loadingLocations?: LoadingLocation[] | null;
    documentSettings?: CustomerDivisionDocumentSettings[] | null;
}

export interface LoadingLocation {
    id?: number;
    address?: Address | null;
    customerDivisionId?: number | null;
    customerPartnerId?: number | null;
    partnerId?: number | null;
    businessHours?: BusinessHours[] | null;
    businessHourExceptions?: BusinessHourException[] | null;
    publicHolidays?: PublicHoliday[] | null;
    detail?: LoadingLocationDetail | null;
}

export interface BusinessHours {
    id?: number;
    dayOfWeek?: DayOfWeek;
    fromTime?: Date;
    toTime?: Date;
}

export enum DayOfWeek {
    Sunday = "Sunday",
    Monday = "Monday",
    Tuesday = "Tuesday",
    Wednesday = "Wednesday",
    Thursday = "Thursday",
    Friday = "Friday",
    Saturday = "Saturday",
}

export interface BusinessHourException {
    id?: number;
    type?: BusinessHourExceptionType;
    fromDateTime?: Date;
    toDateTime?: Date;
}

export enum BusinessHourExceptionType {
    Open = "Open",
    Closed = "Closed",
}

export interface PublicHoliday {
    id?: number;
    name?: string | null;
    date?: Date;
}

export interface LoadingLocationDetail {
    stackHeightMin?: number;
    stackHeightMax?: number;
    supportsPartialMatching?: boolean;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
}

export interface CustomerDivisionDocumentSettings {
    id?: number;
    divisionId?: number;
    documentTypeId?: number;
    defaultPrintCount?: number;
    printCountMin?: number;
    printCountMax?: number;
    override?: boolean;
}

export interface CustomerDivisionCreateRequest {
    name?: string | null;
    shortName?: string | null;
    postingAccountId?: number | null;
    defaultLoadingLocationId?: number | null;
    customerId?: number;
}

export interface CustomerDivisionUpdateRequest {
    id?: number;
    name?: string | null;
    shortName?: string | null;
    postingAccountId?: number | null;
    defaultLoadingLocationId?: number | null;
    customerId?: number;
}

export interface CustomerDocumentSettings {
    id?: number;
    documentTypeId?: number;
    loadCarrierTypeId?: number | null;
    thresholdForWarningQuantity?: number | null;
    maxQuantity?: number | null;
    cancellationTimeSpan?: number | null;
}

export interface Customer {
    id?: number;
    name?: string | null;
    logoUrl?: string | null;
    defaultLanguage?: string | null;
    isPoolingPartner?: boolean;
    settings?: any | null;
    documentSettings?: CustomerDocumentSettings[] | null;
    divisions?: CustomerDivision[] | null;
    customDocumentLabels?: CustomDocumentLabel[] | null;
    loadCarrierReceiptDepotPresets?: LoadCarrierReceiptDepotPreset[] | null;
    parentCustomerId?: number | null;
    refErpCustomerNumber?: number;
    addressId?: number;
    partnerId?: number;
    parentId?: number | null;
    isActive?: boolean;
    organizationId?: number;
}

export interface CustomDocumentLabel {
    customerId?: number | null;
    documentTemplateId?: number;
    languageId?: number;
    reportLabel?: string | null;
    uiLabel?: string | null;
    text?: string | null;
}

export interface LoadCarrierReceiptDepotPreset {
    id?: number;
    category?: LoadCarrierReceiptDepotPresetCategory;
    name?: string | null;
    isSortingRequired?: boolean;
    loadCarriersIds?: number[] | null;
}

export enum LoadCarrierReceiptDepotPresetCategory {
    External = "External",
    Internal = "Internal",
}

export interface CustomerCreateRequest {
    refErpCustomerNumber?: number;
    name?: string | null;
    defaultLanguage?: string | null;
    isPoolingPartner?: boolean;
    addressId?: number;
    organizationId?: number;
    partnerId?: number;
    parentId?: number | null;
    isActive?: boolean;
    settings?: any | null;
}

export interface CustomerUpdateRequest {
    id?: number;
    refErpCustomerNumber?: number;
    name?: string | null;
    defaultLanguage?: string | null;
    isPoolingPartner?: boolean;
    addressId?: number;
    partnerId?: number;
    parentId?: number | null;
    isActive?: boolean;
    settings?: any | null;
}

export interface DocumentType {
    id?: number;
    type?: DocumentTypeEnum;
    name?: string | null;
    shortName?: string | null;
    hasReport?: boolean;
    printType?: PrintType;
    originalAvailableForMinutes?: number;
}

export enum DocumentTypeEnum {
    VoucherDirectReceipt = "VoucherDirectReceipt",
    VoucherDigital = "VoucherDigital",
    VoucherOriginal = "VoucherOriginal",
    LoadCarrierReceiptExchange = "LoadCarrierReceiptExchange",
    LoadCarrierReceiptPickup = "LoadCarrierReceiptPickup",
    LoadCarrierReceiptDelivery = "LoadCarrierReceiptDelivery",
    TransportVoucher = "TransportVoucher",
}

export enum PrintType {
    VoucherCommon = "VoucherCommon",
    LoadCarrierReceiptExchange = "LoadCarrierReceiptExchange",
    LoadCarrierReceiptPickup = "LoadCarrierReceiptPickup",
    LoadCarrierReceiptDelivery = "LoadCarrierReceiptDelivery",
    TransportVoucher = "TransportVoucher",
}

export interface CustomerDivisionDocumentSetting {
    id?: number;
    divisionId?: number;
    documentType?: DocumentType | null;
    documentNumberSequence?: DocumentNumberSequence | null;
    printCountMin?: number;
    printCountMax?: number;
    defaultPrintCount?: number;
    override?: boolean;
}

export interface DocumentNumberSequence {
    id?: number;
    documentType?: DocumentTypeEnum;
    displayName?: string | null;
    counter?: number;
    prefix?: string | null;
    separatorAfterPrefix?: string | null;
    canAddDocumentTypeShortName?: boolean;
    canAddPaddingForCustomerNumber?: boolean;
    paddingLengthForCustomerNumber?: number;
    postfixForCustomerNumber?: string | null;
    canAddDivisionShortName?: boolean;
    prefixForCounter?: string | null;
    canAddPaddingForCounter?: boolean;
    paddingLengthForCounter?: number;
    separator?: string | null;
    customerId?: number;
}

export interface IPaginationResultOfDocument {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: Document[] | null;
}

export interface Document {
    id?: number;
    number?: string | null;
    typeId?: number;
    issuedDateTime?: Date;
    cancellationReason?: string | null;
    divisionId?: number;
    voucherId?: number | null;
    fileIds?: number[] | null;
}

export interface DocumentSettings {
    customers?: CustomerDocumentSettings[] | null;
    divisions?: CustomerDivisionDocumentSettings[] | null;
}

export interface CustomerDocumentSettingsUpdateRequest {
    thresholdForWarningQuantity?: number;
    maxQuantity?: number;
    cancellationTimeSpan?: number;
}

export interface CustomerDivisionDocumentSettingsUpdateRequest {
    defaultPrintCount?: number;
    printCountMin?: number;
    printCountMax?: number;
    override?: boolean;
}

export interface DplEmployeeCustomer {
    type?: DplEmployeeCustomerSelectionEntryType;
    displayName?: string | null;
    displayNameLong?: string | null;
    customerId?: number;
    divisionId?: number | null;
    postingAccountId?: number | null;
    address?: Address | null;
}

export enum DplEmployeeCustomerSelectionEntryType {
    Customer = "Customer",
    Division = "Division",
    PostingAccount = "PostingAccount",
}

export interface IPaginationResultOfExpressCode {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: ExpressCode[] | null;
}

export interface ExpressCode {
    id?: number;
    digitalCode?: string | null;
    bookingText?: string | null;
    validFrom?: Date | null;
    validTo?: Date | null;
    validDischarges?: number | null;
    isCanceled?: boolean;
    voucherReasonTypeId?: number | null;
    voucherType?: VoucherType | null;
    issuingDivisionName?: string | null;
    voucherPresets?: VoucherExpressCodeDetails | null;
    destinationAccountPreset?: DestinationAccountPreset | null;
    loadCarrierReceiptPreset?: LoadCarrierReceiptPreset | null;
}

export enum VoucherType {
    Original = "Original",
    Digital = "Digital",
    Direct = "Direct",
}

export interface VoucherExpressCodeDetails {
    recipient?: CustomerPartner | null;
    shipper?: CustomerPartner | null;
    subShipper?: CustomerPartner | null;
    supplier?: CustomerPartner | null;
}

export interface CustomerPartner {
    id?: number;
    guid?: string;
    type?: PartnerType;
    companyName?: string | null;
    address?: Address | null;
    postingAccountId?: number | null;
    directoryIds?: number[] | null;
    directoryNames?: string[] | null;
}

export enum PartnerType {
    Default = "Default",
    Recipient = "Recipient",
    Supplier = "Supplier",
    Shipper = "Shipper",
    SubShipper = "SubShipper",
}

export interface DestinationAccountPreset {
    postingAccountId?: number;
    loadCarrierId?: number | null;
    loadCarrierQuantity?: number | null;
}

export interface LoadCarrierReceiptPreset {
    type?: LoadCarrierReceiptType | null;
    loadCarrierId?: number;
    loadCarrierQuantity?: number;
    baseLoadCarrierId?: number | null;
    baseLoadCarrierQuantity?: number | null;
    deliveryNoteNumber?: string | null;
    pickupNoteNumber?: string | null;
    refLmsBusinessTypeId?: number | null;
    postingAccountId?: number;
    plannedFulfillmentDateTime?: Date | null;
    refLtmsTransactionRowGuid?: string | null;
}

export enum LoadCarrierReceiptType {
    Pickup = "Pickup",
    Delivery = "Delivery",
    Exchange = "Exchange",
}

export interface ExpressCodeCreateRequest {
    bookingText?: string | null;
    validDischarges?: number | null;
    validFrom?: Date;
    validUntil?: Date | null;
}

export interface ExpressCodeUpdateRequest {
    bookingText?: string | null;
    validUntil?: Date;
    validDischarges?: number | null;
}

export enum LoadCarrierReceiptsSearchRequestSortOptions {
    Type = "Type",
    DocumentNumber = "DocumentNumber",
    IssuedBy = "IssuedBy",
    IssuanceDate = "IssuanceDate",
}

export enum ListSortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export interface LoadCarrierReceipt {
    id?: number;
    type?: LoadCarrierReceiptType;
    trigger?: LoadCarrierReceiptTrigger;
    orderLoadDetailId?: number | null;
    digitalCode?: string | null;
    divisionId?: number;
    divisionName?: string | null;
    issuerCompanyName?: string | null;
    documentId?: number;
    documentNumber?: string | null;
    depotPresetId?: number | null;
    depotPresetCategory?: LoadCarrierReceiptDepotPresetCategory;
    isSortingRequired?: boolean;
    isSortingCompleted?: boolean;
    issuedDate?: Date;
    truckDriverName?: string | null;
    truckDriverCompanyName?: string | null;
    licensePlate?: string | null;
    licensePlateCountryId?: number;
    deliveryNoteNumber?: string | null;
    deliveryNoteShown?: boolean;
    pickUpNoteNumber?: string | null;
    pickUpNoteShown?: boolean;
    customerReference?: string | null;
    shipperCompanyName?: string | null;
    shipperAddress?: Address | null;
    positions?: LoadCarrierReceiptPosition[] | null;
    accountingRecords?: AccountingRecord[] | null;
    downloadLink?: string | null;
    dplNotes?: EmployeeNote[] | null;
}

export enum LoadCarrierReceiptTrigger {
    OrderMatch = "OrderMatch",
    Manual = "Manual",
}

export interface LoadCarrierReceiptPosition {
    id?: number;
    loadCarrierId?: number;
    quantity?: number;
}

export interface LoadCarrierReceiptSortingOption {
    id?: number;
    loadCarrierReceipt?: LoadCarrierReceipt | null;
    sortingPositions?: LoadCarrierReceiptSortingPosition[] | null;
}

export interface LoadCarrierReceiptSortingPosition {
    loadCarrierId?: number;
    quantity?: number;
    possibleSortingQualities?: LoadCarrierQuality[] | null;
}

export interface LoadCarrierQuality {
    id?: number;
    order?: number;
    name?: string | null;
    type?: LoadCarrierQualityType;
}

export enum LoadCarrierQualityType {
    Intact = "Intact",
    Defect = "Defect",
}

export interface LoadCarrierReceiptsCreateRequest {
    digitalCode?: string | null;
    depoPresetId?: number | null;
    isSortingRequired?: boolean;
    type?: LoadCarrierReceiptType;
    customerDivisionId?: number;
    targetPostingAccountId?: number | null;
    truckDriverName?: string | null;
    truckDriverCompanyName?: string | null;
    licensePlate?: string | null;
    licensePlateCountryId?: number;
    refLmsBusinessTypeId?: number | null;
    refLtmsTransactionRowGuid?: string | null;
    deliveryNoteNumber?: string | null;
    deliveryNoteShown?: boolean;
    pickUpNoteNumber?: string | null;
    pickUpNoteShown?: boolean;
    customerReference?: string | null;
    shipperCompanyName?: string | null;
    shipperAddress?: Address | null;
    note?: string | null;
    positions?: LoadCarrierReceiptsCreateRequestPosition[] | null;
    printLanguageId?: number;
    printCount?: number;
    printDateTimeOffset?: number;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface LoadCarrierReceiptsCreateRequestPosition {
    loadCarrierId?: number;
    quantity?: number;
}

export interface LoadCarrierReceiptsCancelRequest {
    reason?: string | null;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface LoadCarrierReceiptsUpdateIsSortingRequiredRequest {
    isSortingRequired?: boolean;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface LoadCarrier {
    id?: number;
    order?: number;
    type?: LoadCarrierType | null;
    quality?: LoadCarrierQuality | null;
}

export interface LoadCarrierType {
    id?: number;
    order?: number;
    quantityPerEur?: number;
    baseLoadCarrier?: BaseLoadCarrierInfo;
    baseLoadCarriers?: LoadCarrier[] | null;
    refLtmsArticleId?: number;
}

export enum BaseLoadCarrierInfo {
    None = "None",
    Optional = "Optional",
    Required = "Required",
}

export interface LoadCarrierSorting {
    id?: number;
    loadCarrierReceiptId?: number;
    positions?: LoadCarrierSortingResult[] | null;
}

export interface LoadCarrierSortingResult {
    loadCarrierId?: number;
    outputs?: LoadCarrierSortingResultOutput[] | null;
}

export interface LoadCarrierSortingResultOutput {
    loadCarrierQualityId?: number;
    quantity?: number;
}

export interface LoadCarrierSortingCreateRequest {
    loadCarrierReceiptId?: number;
    positions?: LoadCarrierSortingResult[] | null;
}

export interface LoadingLocationAdministration {
    id?: number;
    addressId?: number;
    customerDivisionId?: number | null;
    customerPartnerId?: number | null;
    partnerId?: number | null;
    businessHours?: BusinessHours[] | null;
    businessHourExceptions?: BusinessHourException[] | null;
    stackHeightMin?: number;
    stackHeightMax?: number;
    supportsPartialMatching?: boolean;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
}

export interface LoadingLocationsCreateRequest {
    addressId?: number;
    businessHours?: BusinessHours[] | null;
    businessHourExceptions?: BusinessHourException[] | null;
    customerDivisionId?: number | null;
    customerPartnerId?: number | null;
    partnerId?: number | null;
    stackHeightMin?: number;
    stackHeightMax?: number;
    supportsPartialMatching?: boolean;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
}

export interface LoadingLocationsUpdateRequest {
    id?: number;
    addressId?: number;
    customerDivisionId?: number | null;
    customerPartnerId?: number | null;
    partnerId?: number | null;
    stackHeightMin?: number;
    stackHeightMax?: number;
    supportsPartialMatching?: boolean;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
    businessHours?: BusinessHours[] | null;
    businessHourExceptions?: BusinessHourException[] | null;
}

export interface IPaginationResultOfLoadingLocation {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: LoadingLocation[] | null;
}

export interface PaginationRequest {
    page?: number;
    limit?: number;
}

export interface LoadingLocationSearchRequest extends PaginationRequest {
    divisions?: number[] | null;
    partners?: number[] | null;
}

export interface UpdateLoadingLocationRequest {
}

export interface MasterData {
    countries?: Country[] | null;
    documentStates?: DocumentState[] | null;
    languages?: Language[] | null;
    loadCarriers?: LoadCarrier[] | null;
    voucherReasonTypes?: VoucherReasonType[] | null;
}

export interface DocumentState {
    id?: number;
    canBeCanceled?: boolean;
    isCanceled?: boolean;
}

export interface Language {
    id?: number;
    locale?: string | null;
}

export interface VoucherReasonType {
    id?: number;
    order?: number;
}

export interface LoadCarrierOffering {
    address?: Address | null;
    lat?: number;
    lng?: number;
    distance?: number;
    businessHours?: BusinessHours[] | null;
    details?: LoadCarrierOfferingDetail[] | null;
}

export interface LoadCarrierOfferingDetail {
    guid?: string;
    availabilityFrom?: Date;
    availabilityTo?: Date;
    baseLoadCarrierId?: number | null;
    stackHeightMin?: number;
    stackHeightMax?: number;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
}

export enum OrderType {
    Supply = "Supply",
    Demand = "Demand",
}

export enum OrderTransportType {
    Self = "Self",
    ProvidedByOthers = "ProvidedByOthers",
}

export enum OrderQuantityType {
    Load = "Load",
    Stacks = "Stacks",
    LoadCarrierQuantity = "LoadCarrierQuantity",
}

export interface IPaginationResultOfTransportOffering {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: TransportOffering[] | null;
}

export interface TransportOffering {
    id?: number;
    referenceNumber?: string | null;
    status?: TransportOfferingStatus;
    loadType?: TransportLoadType;
    loadCarrierLoad?: TransportOfferingLoadCarrierLoad | null;
    supplyInfo?: TransportOfferingInfo | null;
    demandInfo?: TransportOfferingInfo | null;
    plannedLatestBy?: Date;
    confirmedLatestBy?: Date;
    distance?: number | null;
    stackHeightMin?: number;
    stackHeightMax?: number;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
    winningBid?: TransportOfferingBid | null;
    bids?: TransportOfferingBid[] | null;
}

export enum TransportOfferingStatus {
    Available = "Available",
    BidPlaced = "BidPlaced",
    Won = "Won",
    Lost = "Lost",
    Accepted = "Accepted",
    Declined = "Declined",
    Canceled = "Canceled",
}

export enum TransportLoadType {
    LoadCarrier = "LoadCarrier",
    Other = "Other",
}

export interface TransportOfferingLoadCarrierLoad {
    loadCarrierId?: number | null;
    loadCarrierTypeId?: number;
    loadCarrierQuantity?: number;
}

export interface TransportOfferingInfo {
    address?: Address | null;
    businessHours?: BusinessHours[] | null;
    earliestFulfillmentDateTime?: Date;
    latestFulfillmentDateTime?: Date;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
}

export interface TransportOfferingBid {
    id?: number;
    divisionId?: number;
    status?: TransportBidStatus;
    submittedDateTime?: Date;
    price?: number;
    pickupDate?: Date;
    deliveryDate?: Date;
    note?: string | null;
}

export enum TransportBidStatus {
    Active = "Active",
    Won = "Won",
    Lost = "Lost",
    Accepted = "Accepted",
    Declined = "Declined",
    Canceled = "Canceled",
}

export enum TransportOfferingSortOption {
    ReferenceNumber = "ReferenceNumber",
    SubmittedDate = "SubmittedDate",
    SupplyFulfillmentDate = "SupplyFulfillmentDate",
    DemandFulfillmentDate = "DemandFulfillmentDate",
    SupplyPostalCode = "SupplyPostalCode",
    DemandPostalCode = "DemandPostalCode",
    Status = "Status",
    SupplyCountry = "SupplyCountry",
    DemandCountry = "DemandCountry",
    Distance = "Distance",
}

export interface TransportOfferingBidCreateRequest {
    price?: number;
    pickupDate?: Date;
    deliveryDate?: Date;
    note?: string | null;
    divisionId?: number;
    transportId?: number;
}

export interface TransportOfferingBidAcceptRequest {
    bidId?: number;
}

export interface OrderGroup {
    id?: number;
    orderIds?: number[] | null;
    orders?: Order[] | null;
}

export interface Order {
    id?: number;
    groupId?: number;
    orderNumber?: string | null;
    type?: OrderType;
    transportType?: OrderTransportType;
    status?: OrderStatus;
    postingAccountId?: number;
    loadCarrierId?: number;
    baseLoadCarrierId?: number | null;
    divisionId?: number;
    loadingLocationId?: number | null;
    address?: Address | null;
    quantityType?: OrderQuantityType;
    numberOfStacks?: number | null;
    stackHeightMin?: number;
    stackHeightMax?: number;
    loadCarrierQuantity?: number;
    supportsPartialMatching?: boolean;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
    earliestFulfillmentDateTime?: Date;
    latestFulfillmentDateTime?: Date;
    createdAt?: Date;
    hasDplNote?: boolean;
    loads?: OrderLoad[] | null;
    dplNotes?: EmployeeNote[] | null;
}

export enum OrderStatus {
    Pending = "Pending",
    Confirmed = "Confirmed",
    PartiallyMatched = "PartiallyMatched",
    Matched = "Matched",
    Fulfilled = "Fulfilled",
    CancellationRequested = "CancellationRequested",
    Cancelled = "Cancelled",
    Expired = "Expired",
}

export interface OrderLoad {
    id?: number;
    orderId?: number;
    order?: Order | null;
    orderMatchId?: number;
    digitalCode?: string | null;
    type?: OrderType;
    transportType?: OrderTransportType;
    status?: OrderLoadStatus;
    postingAccountId?: number;
    loadCarrierId?: number;
    baseLoadCarrierId?: number | null;
    loadingLocationId?: number | null;
    address?: Address | null;
    loadCarrierStackHeight?: number;
    loadCarrierQuantity?: number;
    numberOfStacks?: number;
    baseLoadCarrierQuantity?: number;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
    plannedFulfillmentDateTime?: Date;
    actualFulfillmentDateTime?: Date | null;
    createdAt?: Date;
    loadCarrierReceipt?: LoadCarrierReceipt | null;
    dplNotes?: EmployeeNote[] | null;
}

export enum OrderLoadStatus {
    Pending = "Pending",
    TransportPlanned = "TransportPlanned",
    Fulfilled = "Fulfilled",
    CancellationRequested = "CancellationRequested",
    Canceled = "Canceled",
}

export interface OrderGroupsCreateRequest {
    divisionId?: number;
    type?: OrderType;
    transportType?: OrderTransportType;
    postingAccountId?: number;
    loadCarrierId?: number;
    baseLoadCarrierId?: number | null;
    loadingLocationId?: number | null;
    quantityType?: OrderQuantityType;
    numberOfLoads?: number;
    numberOfStacks?: number | null;
    stackHeightMin?: number;
    stackHeightMax?: number;
    loadCarrierQuantity?: number;
    supportsPartialMatching?: boolean;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
    earliestFulfillmentDateTime?: Date;
    latestFulfillmentDateTime?: Date;
    matchLmsOrderGroupRowGuid?: string | null;
    note?: string | null;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface OrderGroupsUpdateRequest {
    postingAccountId?: number;
    type?: OrderType;
    transportType?: OrderTransportType;
    loadCarrierId?: number;
    baseLoadCarrierId?: number | null;
    loadingLocationId?: number;
    quantityType?: OrderQuantityType;
    numberOfLoads?: number;
    numberOfStacks?: number | null;
    stackHeightMin?: number;
    stackHeightMax?: number;
    loadCarrierQuantity?: number;
    supportsPartialMatching?: boolean;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
    earliestFulfillmentDateTime?: Date;
    latestFulfillmentDateTime?: Date;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface OrderGroupCancelRequest {
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface IPaginationResultOfOrderLoad {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: OrderLoad[] | null;
}

export enum OrderLoadSearchRequestSortOptions {
    Id = "Id",
    CreatedAt = "CreatedAt",
    ConfirmedFulfillmentDate = "ConfirmedFulfillmentDate",
    NumberOfLoads = "NumberOfLoads",
    Status = "Status",
    PostalCode = "PostalCode",
    LoadCarrierName = "LoadCarrierName",
    LoadCarrierQuantity = "LoadCarrierQuantity",
    NumberOfStacks = "NumberOfStacks",
    StackHeight = "StackHeight",
    BaseLoadCarrierName = "BaseLoadCarrierName",
    BaseLoadCarrierQuantity = "BaseLoadCarrierQuantity",
    PlannedFulfillmentDateTime = "PlannedFulfillmentDateTime",
    ActualFulfillmentDateTime = "ActualFulfillmentDateTime",
}

export interface OrderLoadCancelRequest {
    note?: string | null;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface IPaginationResultOfOrderMatch {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: OrderMatch[] | null;
}

export interface OrderMatch {
    id?: number;
    orderMatchNumber?: string | null;
    refLmsAvailabilityRowGuid?: string;
    refLmsDeliveryRowGuid?: string;
    refLmsPermanentAvailabilityRowGuid?: string | null;
    refLmsPermanentDeliveryRowGuid?: string | null;
    digitalCode?: string | null;
    transportType?: OrderTransportType;
    selfTransportSide?: OrderType | null;
    status?: OrderMatchStatus;
    supply?: OrderLoad | null;
    supplyCompanyName?: string | null;
    demand?: OrderLoad | null;
    demandCompanyName?: string | null;
    loadCarrierId?: number;
    baseLoadCarrierId?: number | null;
    baseLoadCarrierQuantity?: number;
    loadCarrierStackHeight?: number;
    loadCarrierQuantity?: number;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
}

export enum OrderMatchStatus {
    Pending = "Pending",
    TransportScheduled = "TransportScheduled",
    Cancelled = "Cancelled",
    Fulfilled = "Fulfilled",
}

export interface OrderMatchesCreateRequest {
    supplyOrderRowGuid?: string;
    demandOrderRowGuid?: string;
    transportType?: OrderTransportType;
    selfTransportSide?: OrderType | null;
    skipValidation?: boolean;
    loadCarrierId?: number;
    loadCarrierStackHeight?: number;
    loadCarrierQuantity?: number;
    numberOfStacks?: number;
    baseLoadCarrierId?: number | null;
    baseLoadCarrierQuantity?: number;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
    supplyFulfillmentDateTime?: Date;
    demandFulfillmentDateTime?: Date;
}

export interface OrderMatchesUpdateRequest {
    supplyOrderId?: number;
    demandOrderId?: number;
    loadCarrierId?: number;
    loadCarrierQuantity?: number;
    refLmsAvailabilityRowGuid?: string | null;
    refLmsDeliveryRowGuid?: string | null;
    transportType?: OrderTransportType;
    selfTransportSide?: OrderType | null;
    status?: OrderMatchStatus;
    baseLoadCarrierId?: number | null;
    loadCarrierStackHeight?: number;
    supportsPartialMatching?: boolean;
    supportsRearLoading?: boolean;
    supportsSideLoading?: boolean;
    supportsJumboVehicles?: boolean;
    supplyFulfillmentDateTime?: Date;
    demandFulfillmentDateTime?: Date;
}

export interface IPaginationResultOfOrder {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: Order[] | null;
}

export enum OrderSearchRequestSortOptions {
    Id = "Id",
    CreatedAt = "CreatedAt",
    ConfirmedFulfillmentDate = "ConfirmedFulfillmentDate",
    NumberOfLoads = "NumberOfLoads",
    Status = "Status",
    PostalCode = "PostalCode",
    LoadCarrierName = "LoadCarrierName",
    LoadCarrierQuantity = "LoadCarrierQuantity",
    NumberOfStacks = "NumberOfStacks",
    StackHeightMax = "StackHeightMax",
    BaseLoadCarrierName = "BaseLoadCarrierName",
    BaseLoadCarrierQuantity = "BaseLoadCarrierQuantity",
    EarliestFulfillmentDateTime = "EarliestFulfillmentDateTime",
    LatestFulfillmentDateTime = "LatestFulfillmentDateTime",
    HasDplNote = "HasDplNote",
}

export interface OrderUpdateRequest {
    code?: string | null;
    loadCarrierId?: number;
    loadCarrierQuantity?: number;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface OrderCancelRequest {
    note?: string | null;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface OrderSummary {
    loadCarrierId?: number;
    sum?: OrderAggregate | null;
    count?: OrderAggregate | null;
}

export interface OrderAggregate {
    open?: number;
    confirmed?: number;
    partiallyMatched?: number;
    matched?: number;
    planned?: number;
    fulfilled?: number;
    cancelled?: number;
    expired?: number;
}

export interface OrganizationScopedDataSet {
    id?: number;
    name?: string | null;
    scope?: DomainScope;
    parentId?: number | null;
    organizationId?: number;
}

export enum DomainScope {
    Organization = "Organization",
    Customer = "Customer",
    Division = "Division",
    LoadingLocation = "LoadingLocation",
}

export interface Organization {
    id?: number;
    name?: string | null;
    addressId?: number;
    address?: Address | null;
}

export interface OrganizationCreateRequest {
    name?: string | null;
    addressId?: number;
}

export interface OrganizationUpdateRequest {
    id?: number;
    name?: string | null;
    addressId?: number;
}

export interface PartnerDirectory {
    id?: number;
    name?: string | null;
    partners?: number[] | null;
}

export interface Partner {
    id?: number;
    rowGuid?: string;
    type?: PartnerType;
    companyName?: string | null;
    isPoolingPartner?: boolean;
    defaultAddress?: Address | null;
    addresses?: Address[] | null;
    loadingLocations?: LoadingLocation[] | null;
    defaultPostingAccount?: PostingAccount | null;
    customer?: Customer | null;
    postingAccounts?: PostingAccount[] | null;
    customerPartners?: CustomerPartner[] | null;
}

export interface PostingAccount {
    id?: number;
    refLtmsAccountId?: number;
    refLtmsAccountNumber?: string | null;
    customerNumber?: string | null;
    name?: string | null;
    type?: PostingAccountType;
    address?: Address | null;
    balances?: Balance[] | null;
    transferConditions?: PostingAccountCondition[] | null;
    voucherConditions?: PostingAccountCondition[] | null;
    demandConditions?: PostingAccountCondition[] | null;
    supplyConditions?: PostingAccountCondition[] | null;
    pickupConditions?: PostingAccountCondition[] | null;
    dropoffConditions?: PostingAccountCondition[] | null;
}

export enum PostingAccountType {
    Normal = "Normal",
    SubAccount = "SubAccount",
}

export interface Balance {
    loadCarrierId?: number;
    lastBookingDateTime?: Date;
    provisionalBalance?: number;
    coordinatedBalance?: number;
    availableBalance?: number;
    provisionalCharge?: number;
    provisionalCredit?: number;
    inCoordinationCharge?: number;
    inCoordinationCredit?: number;
    uncoordinatedCharge?: number;
    uncoordinatedCredit?: number;
    postingRequestBalanceCredit?: number;
    postingRequestBalanceCharge?: number;
    latestUncoordinatedCharge?: Date;
    latestUncoordinatedCredit?: Date;
}

export interface PostingAccountCondition {
    refLtmsAccountId?: number;
    type?: PostingAccountConditionType;
    loadCarrierId?: number;
    loadCarrierTypeOrder?: number;
    minQuantity?: number | null;
    maxQuantity?: number | null;
    amount?: number | null;
}

export enum PostingAccountConditionType {
    Undefined = "Undefined",
    Pickup = "Pickup",
    DropOff = "DropOff",
    Demand = "Demand",
    Supply = "Supply",
    Transfer = "Transfer",
    Voucher = "Voucher",
}

export interface PartnersCreateRequest {
    companyName?: string | null;
    type?: PartnerType;
    address?: Address | null;
}

export interface IPaginationResultOfCustomerPartner {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: CustomerPartner[] | null;
}

export interface CustomerPartnersCreateRequest {
    companyName?: string | null;
    type?: PartnerType;
    directoryId?: number;
    address?: Address | null;
}

export interface CustomerPartnersUpdateRequest {
    value?: string | null;
}

export interface GroupPermission {
    resource?: PermissionResourceType;
    referenceId?: number;
    action?: string | null;
}

export enum PermissionResourceType {
    Organization = "Organization",
    Customer = "Customer",
    Division = "Division",
    PostingAccount = "PostingAccount",
}

export interface BalancesSummary {
    postingAccountId?: number;
    loadCarrierTypeId?: number;
    balances?: BalanceOverview[] | null;
    intactBalance?: BalanceOverview | null;
    defectBalance?: BalanceOverview | null;
    postingRequestBalance?: BalanceOverview | null;
}

export interface BalanceOverview {
    name?: string | null;
    coordinatedBalance?: number;
    provisionalCharge?: number;
    provisionalCredit?: number;
    uncoordinatedCharge?: number;
    uncoordinatedCredit?: number;
}

export interface LtmsAccount {
    id?: number;
    name?: string | null;
    accountNumber?: string | null;
    customerNumber?: string | null;
}

export interface PostingAccountAdministration {
    id?: number;
    refLtmsAccountId?: number;
    refLtmsAccountNumber?: string | null;
    customerNumber?: string | null;
    displayName?: string | null;
    type?: PostingAccountType;
    addressId?: number;
    addressStreet1?: string | null;
    addressCity?: string | null;
    addressPostalCode?: string | null;
}

export interface AllowedPostingAccount {
    postingAccountId?: number;
    displayName?: string | null;
}

export interface PostingRequestsCreateRequest {
    referenceNumber?: string | null;
    refLtmsProcessId?: string;
    refLtmsProcessTypeId?: number;
    refLtmsTransactionId?: string;
    reason?: PostingRequestReason;
    type?: PostingRequestType;
    isSortingRequired?: boolean;
    orderMatchId?: number | null;
    voucherId?: number | null;
    submissionId?: number | null;
    sourceRefLtmsAccountId?: number;
    destinationRefLtmsAccountId?: number;
    positions?: PostingRequestPosition[] | null;
    postingAccountId?: number;
    note?: string | null;
    loadCarrierReceiptId?: number | null;
    documentFileName?: string | null;
    isSelfService?: boolean | null;
    dplNote?: EmployeeNoteCreateRequest | null;
    digitalCode?: string | null;
    deliveryNoteNumber?: string | null;
    pickUpNoteNumber?: string | null;
    refLmsBusinessTypeId?: number | null;
    refLtmsTransactionRowGuid?: string | null;
}

export interface PostingRequestPosition {
    loadCarrierId?: number;
    loadCarrierQuantity?: number;
    refLtmsBookingRowGuid?: string;
    refLtmsPalletId?: number;
}

export interface PostingRequestsUpdateRequest {
    id?: number;
    referenceNumber?: string | null;
    refLtmsProcessId?: string;
    refLtmsProcessTypeId?: number;
    refLtmsTransactionId?: string;
    reason?: PostingRequestReason;
    type?: PostingRequestType;
    status?: PostingRequestStatus;
    orderMatchId?: number | null;
    voucherId?: number | null;
    submissionId?: number | null;
    sourceRefLtmsAccountId?: number;
    destinationRefLtmsAccountId?: number;
    loadCarrierId?: number;
    loadCarrierQuantity?: number;
    note?: string | null;
}

export interface IPaginationResultOfUpload {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: Upload[] | null;
}

export interface Upload {
    id?: number;
}

export interface CreateUploadRequest {
    value?: string | null;
}

export interface UpdateUploadRequest {
    value?: string | null;
}

export interface UserListItem {
    id?: number;
    upn?: string | null;
    createdAt?: Date;
    changedAt?: Date | null;
    locked?: boolean;
    firstLoginDate?: Date | null;
    lastLoginDate?: Date | null;
    role?: string | null;
    personId?: number;
    gender?: string | null;
    salutation?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    mobileNumber?: string | null;
    firstLoginPassword?: string | null;
}

export interface User {
    id?: number;
    upn?: string | null;
    role?: UserRole;
    person?: Person | null;
    customers?: Customer[] | null;
    postingAccounts?: PostingAccount[] | null;
    permissions?: UserPermission[] | null;
    settings?: any | null;
}

export enum UserRole {
    Retailer = "Retailer",
    Warehouse = "Warehouse",
    Shipper = "Shipper",
    DplEmployee = "DplEmployee",
}

export interface Person {
    id?: number;
    gender?: PersonGender;
    salutation?: string | null;
    firstName?: string | null;
    lastName?: string | null;
    email?: string | null;
    phoneNumber?: string | null;
    mobileNumber?: string | null;
}

export enum PersonGender {
    None = "None",
    Female = "Female",
    Male = "Male",
    Other = "Other",
}

export interface UserPermission {
    resource?: PermissionResourceType;
    referenceId?: number;
    action?: ResourceAction;
}

export enum ResourceAction {
    Create = "Create",
    Update = "Update",
    Read = "Read",
    Delete = "Delete",
    CreateCustomer = "CreateCustomer",
    UpdateCustomer = "UpdateCustomer",
    DeleteCustomer = "DeleteCustomer",
    CreateDivision = "CreateDivision",
    UpdateDivision = "UpdateDivision",
    DeleteDivision = "DeleteDivision",
    CreateVoucher = "CreateVoucher",
    CancelVoucher = "CancelVoucher",
    SubmitVoucher = "SubmitVoucher",
    ReadVoucher = "ReadVoucher",
    CreateLoadCarrierReceipt = "CreateLoadCarrierReceipt",
    CancelLoadCarrierReceipt = "CancelLoadCarrierReceipt",
    ReadLoadCarrierReceipt = "ReadLoadCarrierReceipt",
    UpdateOrder = "UpdateOrder",
    CreateOrder = "CreateOrder",
    CancelOrder = "CancelOrder",
    ReadOrder = "ReadOrder",
    ReadBalanceTransfer = "ReadBalanceTransfer",
    CreateBalanceTransfer = "CreateBalanceTransfer",
    CancelBalanceTransfer = "CancelBalanceTransfer",
    CancelOrderLoad = "CancelOrderLoad",
    ReadOrderLoad = "ReadOrderLoad",
    CreateExpressCode = "CreateExpressCode",
    ReadExpressCode = "ReadExpressCode",
    CancelExpressCode = "CancelExpressCode",
    ReadAccountingRecords = "ReadAccountingRecords",
    CreateLivePoolingSearch = "CreateLivePoolingSearch",
    ReadLivePoolingOrders = "ReadLivePoolingOrders",
    CreateSorting = "CreateSorting",
}

export interface UserResetPasswordResult {
    newPassword?: string | null;
}

export interface UserGroupListItem {
    id?: number;
    type?: string | null;
    name?: string | null;
    isSystemGroup?: boolean;
    permissions?: GroupPermission[] | null;
}

export interface IPaginationResultOfVoucher {
    perPage?: number;
    lastPage?: number;
    currentPage?: number;
    total?: number;
    data?: Voucher[] | null;
}

export interface Voucher {
    id?: number;
    divisionId?: number;
    divisionName?: string | null;
    issuerCompanyName?: string | null;
    documentId?: number;
    documentNumber?: string | null;
    type?: VoucherType;
    status?: VoucherStatus;
    issuedDate?: Date;
    validUntil?: Date;
    licensePlate?: string | null;
    truckDriverName?: string | null;
    truckDriverCompanyName?: string | null;
    recipientId?: number;
    recipient?: string | null;
    recipientType?: PartnerType;
    supplierId?: number | null;
    supplier?: string | null;
    shipperId?: number | null;
    shipper?: string | null;
    subShipperId?: number | null;
    subShipper?: string | null;
    reasonTypeId?: number;
    cancellationReason?: string | null;
    procurementLogistics?: boolean;
    customerReference?: string | null;
    positions?: VoucherPosition[] | null;
    accountingRecords?: AccountingRecord[] | null;
    downloadLink?: string | null;
    hasDplNote?: boolean;
    dplNotes?: EmployeeNote[] | null;
}

export enum VoucherStatus {
    Issued = "Issued",
    Submitted = "Submitted",
    Accounted = "Accounted",
    Expired = "Expired",
    Canceled = "Canceled",
}

export interface VoucherPosition {
    id?: number;
    loadCarrierId?: number;
    quantity?: number;
}

export enum VouchersSearchRequestSortOptions {
    DocumentNumber = "DocumentNumber",
    IssuedBy = "IssuedBy",
    IssuanceDate = "IssuanceDate",
    ValidUntil = "ValidUntil",
    RecipientType = "RecipientType",
    Recipient = "Recipient",
    Reason = "Reason",
    Type = "Type",
    Status = "Status",
    Supplier = "Supplier",
    SubShipper = "SubShipper",
    Shipper = "Shipper",
    Quantity = "Quantity",
    HasDplNote = "HasDplNote",
    CustomerReference = "CustomerReference",
}

export interface VouchersCreateRequest {
    customerDivisionId?: number;
    expressCode?: string | null;
    reasonTypeId?: number;
    type?: VoucherType;
    truckDriverName?: string | null;
    truckDriverCompanyName?: string | null;
    licensePlate?: string | null;
    licensePlateCountryId?: number | null;
    note?: string | null;
    recipientGuid?: string;
    recipientType?: PartnerType | null;
    supplierGuid?: string;
    shipperGuid?: string;
    subShipperGuid?: string;
    positions?: VouchersCreateRequestPosition[] | null;
    procurementLogistics?: boolean;
    customerReference?: string | null;
    printLanguageId?: number;
    printCount?: number;
    printDateTimeOffset?: number;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface VouchersCreateRequestPosition {
    loadCarrierId?: number;
    quantity?: number;
}

export interface VouchersAddToSubmissionRequest {
    submissionId?: number;
}

export interface VouchersRemoveFromSubmissionRequest {
    submissionId?: number;
}

export interface VouchersCancelRequest {
    reason?: string | null;
    dplNote?: EmployeeNoteCreateRequest | null;
}

export interface VoucherSummary {
    loadCarrierTypeId?: number;
    sum?: VoucherAggregate | null;
    count?: VoucherAggregate | null;
    order?: number;
}

export interface VoucherAggregate {
    issued?: number;
    submitted?: number;
    accounted?: number;
    canceled?: number;
    expired?: number;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}