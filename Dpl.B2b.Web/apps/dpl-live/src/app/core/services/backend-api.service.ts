/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.4.0 (NJsonSchema v10.0.21.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {
  mergeMap as _observableMergeMap,
  catchError as _observableCatch,
} from 'rxjs/operators';
import {
  Observable,
  throwError as _observableThrow,
  of as _observableOf,
} from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import {
  HttpClient,
  HttpHeaders,
  HttpResponse,
  HttpResponseBase,
} from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
  providedIn: 'root',
})
export class OrderManagementApiService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  findAddresses(
    request: AddressSearchRequest
  ): Observable<IAddressSearchResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/FindAddresses';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(request);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processFindAddresses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processFindAddresses(<any>response_);
            } catch (e) {
              return <Observable<IAddressSearchResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IAddressSearchResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processFindAddresses(
    response: HttpResponseBase
  ): Observable<IAddressSearchResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IAddressSearchResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IAddressSearchResponse>(<any>null);
  }

  getDocuments(uploadId: number, fileTypeId: number): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetDocuments?';
    if (uploadId === undefined || uploadId === null)
      throw new Error(
        "The parameter 'uploadId' must be defined and cannot be null."
      );
    else url_ += 'uploadId=' + encodeURIComponent('' + uploadId) + '&';
    if (fileTypeId === undefined || fileTypeId === null)
      throw new Error(
        "The parameter 'fileTypeId' must be defined and cannot be null."
      );
    else url_ += 'fileTypeId=' + encodeURIComponent('' + fileTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocuments(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocuments(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocuments(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getUploadsByUser(skippedUploads: number): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetUploadsByUser?';
    if (skippedUploads === undefined || skippedUploads === null)
      throw new Error(
        "The parameter 'skippedUploads' must be defined and cannot be null."
      );
    else
      url_ += 'skippedUploads=' + encodeURIComponent('' + skippedUploads) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUploadsByUser(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUploadsByUser(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUploadsByUser(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getDocumentsByUploadId(uploadId: number): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetDocumentsByUploadId?';
    if (uploadId === undefined || uploadId === null)
      throw new Error(
        "The parameter 'uploadId' must be defined and cannot be null."
      );
    else url_ += 'uploadId=' + encodeURIComponent('' + uploadId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentsByUploadId(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentsByUploadId(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentsByUploadId(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getUploads(): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetUploads';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUploads(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUploads(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUploads(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  cancelOrder(orderRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/CancelOrder?';
    if (orderRequestJObject === undefined || orderRequestJObject === null)
      throw new Error(
        "The parameter 'orderRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderRequestJObject=' +
        encodeURIComponent('' + orderRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCancelOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCancelOrder(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCancelOrder(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  createAddress(addressRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/CreateAddress?';
    if (addressRequestJObject === undefined || addressRequestJObject === null)
      throw new Error(
        "The parameter 'addressRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'addressRequestJObject=' +
        encodeURIComponent('' + addressRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateAddress(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateAddress(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateAddress(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  createOrder(orderRequestJObject: any): Observable<IOrderResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/CreateOrder';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(orderRequestJObject);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrder(<any>response_);
            } catch (e) {
              return <Observable<IOrderResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IOrderResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processCreateOrder(
    response: HttpResponseBase
  ): Observable<IOrderResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IOrderResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IOrderResponse>(<any>null);
  }

  createOrderTemplate(orderTemplateRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/CreateOrderTemplate?';
    if (
      orderTemplateRequestJObject === undefined ||
      orderTemplateRequestJObject === null
    )
      throw new Error(
        "The parameter 'orderTemplateRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateRequestJObject=' +
        encodeURIComponent('' + orderTemplateRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrderTemplate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrderTemplate(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrderTemplate(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  createOrderTemplateCollection(
    orderTemplateRequestCollectionJObject: any
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/CreateOrderTemplateCollection?';
    if (
      orderTemplateRequestCollectionJObject === undefined ||
      orderTemplateRequestCollectionJObject === null
    )
      throw new Error(
        "The parameter 'orderTemplateRequestCollectionJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateRequestCollectionJObject=' +
        encodeURIComponent('' + orderTemplateRequestCollectionJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOrderTemplateCollection(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOrderTemplateCollection(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOrderTemplateCollection(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  deleteAddress(
    postingAccountId: number,
    addressId: number
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/DeleteAddress?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (addressId === undefined || addressId === null)
      throw new Error(
        "The parameter 'addressId' must be defined and cannot be null."
      );
    else url_ += 'addressId=' + encodeURIComponent('' + addressId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteAddress(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteAddress(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteAddress(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  deleteDeliveryNotePdf(
    orderNumber: string,
    deliveryNoteNumber: string,
    postingAccountId: number
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/DeleteDeliveryNotePdf?';
    if (orderNumber === undefined || orderNumber === null)
      throw new Error(
        "The parameter 'orderNumber' must be defined and cannot be null."
      );
    else url_ += 'orderNumber=' + encodeURIComponent('' + orderNumber) + '&';
    if (deliveryNoteNumber === undefined || deliveryNoteNumber === null)
      throw new Error(
        "The parameter 'deliveryNoteNumber' must be defined and cannot be null."
      );
    else
      url_ +=
        'deliveryNoteNumber=' +
        encodeURIComponent('' + deliveryNoteNumber) +
        '&';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteDeliveryNotePdf(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteDeliveryNotePdf(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteDeliveryNotePdf(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  deleteOrder(
    orderId: number,
    postingAccountId: number
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/DeleteOrder?';
    if (orderId === undefined || orderId === null)
      throw new Error(
        "The parameter 'orderId' must be defined and cannot be null."
      );
    else url_ += 'orderId=' + encodeURIComponent('' + orderId) + '&';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteOrder(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteOrder(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  deleteOrderTemplate(
    orderTemplateId: number,
    postingAccountId: number
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/DeleteOrderTemplate?';
    if (orderTemplateId === undefined || orderTemplateId === null)
      throw new Error(
        "The parameter 'orderTemplateId' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateId=' + encodeURIComponent('' + orderTemplateId) + '&';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteOrderTemplate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteOrderTemplate(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteOrderTemplate(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  deleteOrderTemplateCollection(
    orderTemplateCollectionId: number,
    postingAccountId: number
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/DeleteOrderTemplateCollection?';
    if (
      orderTemplateCollectionId === undefined ||
      orderTemplateCollectionId === null
    )
      throw new Error(
        "The parameter 'orderTemplateCollectionId' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateCollectionId=' +
        encodeURIComponent('' + orderTemplateCollectionId) +
        '&';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('delete', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeleteOrderTemplateCollection(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeleteOrderTemplateCollection(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeleteOrderTemplateCollection(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  duplicateOrders(ordersRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/DuplicateOrders?';
    if (ordersRequestJObject === undefined || ordersRequestJObject === null)
      throw new Error(
        "The parameter 'ordersRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'ordersRequestJObject=' +
        encodeURIComponent('' + ordersRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDuplicateOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDuplicateOrders(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDuplicateOrders(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  generateOrdersFromTemplates(orderRequestJObject: any): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/GenerateOrdersFromTemplates?';
    if (orderRequestJObject === undefined || orderRequestJObject === null)
      throw new Error(
        "The parameter 'orderRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderRequestJObject=' +
        encodeURIComponent('' + orderRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGenerateOrdersFromTemplates(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGenerateOrdersFromTemplates(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGenerateOrdersFromTemplates(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  generateOrdersFromWeek(ordersRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GenerateOrdersFromWeek?';
    if (ordersRequestJObject === undefined || ordersRequestJObject === null)
      throw new Error(
        "The parameter 'ordersRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'ordersRequestJObject=' +
        encodeURIComponent('' + ordersRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGenerateOrdersFromWeek(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGenerateOrdersFromWeek(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGenerateOrdersFromWeek(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  generateTemplatesFromOrders(
    ordersRequestJObject: any
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/GenerateTemplatesFromOrders?';
    if (ordersRequestJObject === undefined || ordersRequestJObject === null)
      throw new Error(
        "The parameter 'ordersRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'ordersRequestJObject=' +
        encodeURIComponent('' + ordersRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGenerateTemplatesFromOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGenerateTemplatesFromOrders(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGenerateTemplatesFromOrders(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getAddress(addressId: number): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetAddress?';
    if (addressId === undefined || addressId === null)
      throw new Error(
        "The parameter 'addressId' must be defined and cannot be null."
      );
    else url_ += 'addressId=' + encodeURIComponent('' + addressId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAddress(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAddress(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAddress(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getAddresses(postingAccountId: number): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetAddresses?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAddresses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAddresses(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetAddresses(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getDeliveryNoteDocuments(
    guid: string,
    isDeliveryNoteFilesRequested: boolean,
    isDeliveryNotePhotosRequested: boolean
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetDeliveryNoteDocuments?';
    if (guid === undefined || guid === null)
      throw new Error(
        "The parameter 'guid' must be defined and cannot be null."
      );
    else url_ += 'guid=' + encodeURIComponent('' + guid) + '&';
    if (
      isDeliveryNoteFilesRequested === undefined ||
      isDeliveryNoteFilesRequested === null
    )
      throw new Error(
        "The parameter 'isDeliveryNoteFilesRequested' must be defined and cannot be null."
      );
    else
      url_ +=
        'isDeliveryNoteFilesRequested=' +
        encodeURIComponent('' + isDeliveryNoteFilesRequested) +
        '&';
    if (
      isDeliveryNotePhotosRequested === undefined ||
      isDeliveryNotePhotosRequested === null
    )
      throw new Error(
        "The parameter 'isDeliveryNotePhotosRequested' must be defined and cannot be null."
      );
    else
      url_ +=
        'isDeliveryNotePhotosRequested=' +
        encodeURIComponent('' + isDeliveryNotePhotosRequested) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDeliveryNoteDocuments(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDeliveryNoteDocuments(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDeliveryNoteDocuments(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getFileById(fileId: number): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetFileById?';
    if (fileId === undefined || fileId === null)
      throw new Error(
        "The parameter 'fileId' must be defined and cannot be null."
      );
    else url_ += 'fileId=' + encodeURIComponent('' + fileId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetFileById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetFileById(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetFileById(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  getDeliveryNotePdf(
    orderNumber: string,
    deliveryNoteNumber: string,
    postingAccountId: number
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetDeliveryNotePdf?';
    if (orderNumber === undefined || orderNumber === null)
      throw new Error(
        "The parameter 'orderNumber' must be defined and cannot be null."
      );
    else url_ += 'orderNumber=' + encodeURIComponent('' + orderNumber) + '&';
    if (deliveryNoteNumber === undefined || deliveryNoteNumber === null)
      throw new Error(
        "The parameter 'deliveryNoteNumber' must be defined and cannot be null."
      );
    else
      url_ +=
        'deliveryNoteNumber=' +
        encodeURIComponent('' + deliveryNoteNumber) +
        '&';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDeliveryNotePdf(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDeliveryNotePdf(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDeliveryNotePdf(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  getDocumentByGuid(
    uploadProcessGuid: string,
    documentGuid: string,
    contentType: string
  ): Observable<FileResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetDocumentByGuid?';
    if (uploadProcessGuid === undefined || uploadProcessGuid === null)
      throw new Error(
        "The parameter 'uploadProcessGuid' must be defined and cannot be null."
      );
    else
      url_ +=
        'uploadProcessGuid=' + encodeURIComponent('' + uploadProcessGuid) + '&';
    if (documentGuid === undefined || documentGuid === null)
      throw new Error(
        "The parameter 'documentGuid' must be defined and cannot be null."
      );
    else url_ += 'documentGuid=' + encodeURIComponent('' + documentGuid) + '&';
    if (contentType === undefined || contentType === null)
      throw new Error(
        "The parameter 'contentType' must be defined and cannot be null."
      );
    else url_ += 'contentType=' + encodeURIComponent('' + contentType) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/octet-stream',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetDocumentByGuid(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetDocumentByGuid(<any>response_);
            } catch (e) {
              return <Observable<FileResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<FileResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetDocumentByGuid(
    response: HttpResponseBase
  ): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers
        ? response.headers.get('content-disposition')
        : undefined;
      const fileNameMatch = contentDisposition
        ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition)
        : undefined;
      const fileName =
        fileNameMatch && fileNameMatch.length > 1
          ? fileNameMatch[1]
          : undefined;
      return _observableOf({
        fileName: fileName,
        data: <any>responseBlob,
        status: status,
        headers: _headers,
      });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<FileResponse>(<any>null);
  }

  getOrder(orderNumberOrGuid: string): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetOrder?';
    if (orderNumberOrGuid === undefined || orderNumberOrGuid === null)
      throw new Error(
        "The parameter 'orderNumberOrGuid' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderNumberOrGuid=' + encodeURIComponent('' + orderNumberOrGuid) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrder(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrder(response: HttpResponseBase): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getOrderByDigitalCode(digitalCode: string): Observable<IOrderResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetOrderByDigitalCode?';
    if (digitalCode === undefined || digitalCode === null)
      throw new Error(
        "The parameter 'digitalCode' must be defined and cannot be null."
      );
    else url_ += 'digitalCode=' + encodeURIComponent('' + digitalCode) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrderByDigitalCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrderByDigitalCode(<any>response_);
            } catch (e) {
              return <Observable<IOrderResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IOrderResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetOrderByDigitalCode(
    response: HttpResponseBase
  ): Observable<IOrderResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IOrderResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IOrderResponse>(<any>null);
  }

  getOrderFormData(
    postingAccountId: number,
    orderTypeId: number
  ): Observable<IFormDataResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetOrderFormData?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (orderTypeId === undefined || orderTypeId === null)
      throw new Error(
        "The parameter 'orderTypeId' must be defined and cannot be null."
      );
    else url_ += 'orderTypeId=' + encodeURIComponent('' + orderTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrderFormData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrderFormData(<any>response_);
            } catch (e) {
              return <Observable<IFormDataResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IFormDataResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetOrderFormData(
    response: HttpResponseBase
  ): Observable<IFormDataResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IFormDataResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IFormDataResponse>(<any>null);
  }

  getOrders(
    postingAccountId: number,
    displayedWeek: Date
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetOrders?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (displayedWeek === undefined || displayedWeek === null)
      throw new Error(
        "The parameter 'displayedWeek' must be defined and cannot be null."
      );
    else
      url_ +=
        'displayedWeek=' +
        encodeURIComponent(displayedWeek ? '' + displayedWeek.toJSON() : '') +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrders(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrders(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getOrdersByOrderType(
    postingAccountId: number,
    orderTypeId: number,
    displayedWeek: Date
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetOrdersByOrderType?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (orderTypeId === undefined || orderTypeId === null)
      throw new Error(
        "The parameter 'orderTypeId' must be defined and cannot be null."
      );
    else url_ += 'orderTypeId=' + encodeURIComponent('' + orderTypeId) + '&';
    if (displayedWeek === undefined || displayedWeek === null)
      throw new Error(
        "The parameter 'displayedWeek' must be defined and cannot be null."
      );
    else
      url_ +=
        'displayedWeek=' +
        encodeURIComponent(displayedWeek ? '' + displayedWeek.toJSON() : '') +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrdersByOrderType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrdersByOrderType(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrdersByOrderType(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getOrderSearchFormData(
    postingAccountId: number
  ): Observable<IFormDataResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetOrderSearchFormData?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrderSearchFormData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrderSearchFormData(<any>response_);
            } catch (e) {
              return <Observable<IFormDataResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IFormDataResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetOrderSearchFormData(
    response: HttpResponseBase
  ): Observable<IFormDataResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IFormDataResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IFormDataResponse>(<any>null);
  }

  getOrderTemplate(orderTemplateId: number): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetOrderTemplate?';
    if (orderTemplateId === undefined || orderTemplateId === null)
      throw new Error(
        "The parameter 'orderTemplateId' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateId=' + encodeURIComponent('' + orderTemplateId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrderTemplate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrderTemplate(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrderTemplate(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getOrderTemplateCollection(
    orderTemplateRequestCollectionJObject: any
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/GetOrderTemplateCollection?';
    if (
      orderTemplateRequestCollectionJObject === undefined ||
      orderTemplateRequestCollectionJObject === null
    )
      throw new Error(
        "The parameter 'orderTemplateRequestCollectionJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateRequestCollectionJObject=' +
        encodeURIComponent('' + orderTemplateRequestCollectionJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrderTemplateCollection(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrderTemplateCollection(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrderTemplateCollection(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getOrderTemplateCollectionByName(
    templateCollectionName: string,
    postingAccountId: number
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/GetOrderTemplateCollectionByName?';
    if (templateCollectionName === undefined || templateCollectionName === null)
      throw new Error(
        "The parameter 'templateCollectionName' must be defined and cannot be null."
      );
    else
      url_ +=
        'templateCollectionName=' +
        encodeURIComponent('' + templateCollectionName) +
        '&';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrderTemplateCollectionByName(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrderTemplateCollectionByName(
                <any>response_
              );
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrderTemplateCollectionByName(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getOrderTemplateCollections(postingAccountId: number): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/GetOrderTemplateCollections?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrderTemplateCollections(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrderTemplateCollections(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrderTemplateCollections(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getOrderTemplateCollectionsByOrderTypeId(
    postingAccountId: number,
    orderTypeId: number
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl +
      '/api/OrderManagement/GetOrderTemplateCollectionsByOrderTypeId?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (orderTypeId === undefined || orderTypeId === null)
      throw new Error(
        "The parameter 'orderTypeId' must be defined and cannot be null."
      );
    else url_ += 'orderTypeId=' + encodeURIComponent('' + orderTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrderTemplateCollectionsByOrderTypeId(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrderTemplateCollectionsByOrderTypeId(
                <any>response_
              );
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrderTemplateCollectionsByOrderTypeId(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getOrderTemplates(
    orderTemplateCollectionGuid: string
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetOrderTemplates?';
    if (
      orderTemplateCollectionGuid === undefined ||
      orderTemplateCollectionGuid === null
    )
      throw new Error(
        "The parameter 'orderTemplateCollectionGuid' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateCollectionGuid=' +
        encodeURIComponent('' + orderTemplateCollectionGuid) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOrderTemplates(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOrderTemplates(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOrderTemplates(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getPostingAccountOrdersStatisticsByOrderTypeId(
    postingAccountId: number,
    orderTypeId: number
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl +
      '/api/OrderManagement/GetPostingAccountOrdersStatisticsByOrderTypeId?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (orderTypeId === undefined || orderTypeId === null)
      throw new Error(
        "The parameter 'orderTypeId' must be defined and cannot be null."
      );
    else url_ += 'orderTypeId=' + encodeURIComponent('' + orderTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPostingAccountOrdersStatisticsByOrderTypeId(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPostingAccountOrdersStatisticsByOrderTypeId(
                <any>response_
              );
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPostingAccountOrdersStatisticsByOrderTypeId(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getPostingAccounts(): Observable<IOrderResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetPostingAccounts';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPostingAccounts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPostingAccounts(<any>response_);
            } catch (e) {
              return <Observable<IOrderResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IOrderResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPostingAccounts(
    response: HttpResponseBase
  ): Observable<IOrderResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IOrderResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IOrderResponse>(<any>null);
  }

  getPostingAccountsByOrderType(
    orderTypeId: number
  ): Observable<IOrderResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/GetPostingAccountsByOrderType?';
    if (orderTypeId === undefined || orderTypeId === null)
      throw new Error(
        "The parameter 'orderTypeId' must be defined and cannot be null."
      );
    else url_ += 'orderTypeId=' + encodeURIComponent('' + orderTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPostingAccountsByOrderType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPostingAccountsByOrderType(<any>response_);
            } catch (e) {
              return <Observable<IOrderResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IOrderResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPostingAccountsByOrderType(
    response: HttpResponseBase
  ): Observable<IOrderResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IOrderResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IOrderResponse>(<any>null);
  }

  getUploadById(uploadId: number): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetUploadById?';
    if (uploadId === undefined || uploadId === null)
      throw new Error(
        "The parameter 'uploadId' must be defined and cannot be null."
      );
    else url_ += 'uploadId=' + encodeURIComponent('' + uploadId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUploadById(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUploadById(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUploadById(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getReceiptedDeliveryNotes(
    postingAccountId: number,
    isApproved: boolean,
    isRejected: boolean,
    isUnchecked: boolean
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetReceiptedDeliveryNotes?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (isApproved === undefined || isApproved === null)
      throw new Error(
        "The parameter 'isApproved' must be defined and cannot be null."
      );
    else url_ += 'isApproved=' + encodeURIComponent('' + isApproved) + '&';
    if (isRejected === undefined || isRejected === null)
      throw new Error(
        "The parameter 'isRejected' must be defined and cannot be null."
      );
    else url_ += 'isRejected=' + encodeURIComponent('' + isRejected) + '&';
    if (isUnchecked === undefined || isUnchecked === null)
      throw new Error(
        "The parameter 'isUnchecked' must be defined and cannot be null."
      );
    else url_ += 'isUnchecked=' + encodeURIComponent('' + isUnchecked) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetReceiptedDeliveryNotes(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetReceiptedDeliveryNotes(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetReceiptedDeliveryNotes(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getTemplateFormData(
    orderTemplateCollectionId: number,
    postingAccountId: number
  ): Observable<IFormDataResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetTemplateFormData?';
    if (
      orderTemplateCollectionId === undefined ||
      orderTemplateCollectionId === null
    )
      throw new Error(
        "The parameter 'orderTemplateCollectionId' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateCollectionId=' +
        encodeURIComponent('' + orderTemplateCollectionId) +
        '&';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetTemplateFormData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetTemplateFormData(<any>response_);
            } catch (e) {
              return <Observable<IFormDataResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IFormDataResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetTemplateFormData(
    response: HttpResponseBase
  ): Observable<IFormDataResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IFormDataResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IFormDataResponse>(<any>null);
  }

  getUploaderProfile(): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GetUploaderProfile';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetUploaderProfile(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetUploaderProfile(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetUploaderProfile(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  grantOrders(ordersRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GrantOrders?';
    if (ordersRequestJObject === undefined || ordersRequestJObject === null)
      throw new Error(
        "The parameter 'ordersRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'ordersRequestJObject=' +
        encodeURIComponent('' + ordersRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGrantOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGrantOrders(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGrantOrders(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  generateDemoOrders(ordersRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/GenerateDemoOrders?';
    if (ordersRequestJObject === undefined || ordersRequestJObject === null)
      throw new Error(
        "The parameter 'ordersRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'ordersRequestJObject=' +
        encodeURIComponent('' + ordersRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGenerateDemoOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGenerateDemoOrders(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGenerateDemoOrders(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  saveDocumentApprovalResult(
    documentApprovalRequestJObject: any
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/SaveDocumentApprovalResult?';
    if (
      documentApprovalRequestJObject === undefined ||
      documentApprovalRequestJObject === null
    )
      throw new Error(
        "The parameter 'documentApprovalRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'documentApprovalRequestJObject=' +
        encodeURIComponent('' + documentApprovalRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSaveDocumentApprovalResult(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSaveDocumentApprovalResult(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSaveDocumentApprovalResult(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  refreshAddresses(postingAccountId: number): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/RefreshAddresses?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRefreshAddresses(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRefreshAddresses(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRefreshAddresses(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  requestOrderCancellation(orderRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/RequestOrderCancellation?';
    if (orderRequestJObject === undefined || orderRequestJObject === null)
      throw new Error(
        "The parameter 'orderRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderRequestJObject=' +
        encodeURIComponent('' + orderRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRequestOrderCancellation(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRequestOrderCancellation(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processRequestOrderCancellation(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  searchOrders(orderSearchRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/SearchOrders?';
    if (
      orderSearchRequestJObject === undefined ||
      orderSearchRequestJObject === null
    )
      throw new Error(
        "The parameter 'orderSearchRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderSearchRequestJObject=' +
        encodeURIComponent('' + orderSearchRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSearchOrders(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSearchOrders(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSearchOrders(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  switchAddressState(
    postingAccountId: number,
    addressId: number
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/SwitchAddressState?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (addressId === undefined || addressId === null)
      throw new Error(
        "The parameter 'addressId' must be defined and cannot be null."
      );
    else url_ += 'addressId=' + encodeURIComponent('' + addressId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSwitchAddressState(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSwitchAddressState(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSwitchAddressState(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  updateAddress(addressRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/UpdateAddress?';
    if (addressRequestJObject === undefined || addressRequestJObject === null)
      throw new Error(
        "The parameter 'addressRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'addressRequestJObject=' +
        encodeURIComponent('' + addressRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateAddress(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateAddress(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateAddress(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  updateOrder(orderRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/UpdateOrder?';
    if (orderRequestJObject === undefined || orderRequestJObject === null)
      throw new Error(
        "The parameter 'orderRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderRequestJObject=' +
        encodeURIComponent('' + orderRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateOrder(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateOrder(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateOrder(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  redeemCode(
    digitalCode: string,
    quantity: number
  ): Observable<IOrderResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/RedeemCode?';
    if (digitalCode === undefined || digitalCode === null)
      throw new Error(
        "The parameter 'digitalCode' must be defined and cannot be null."
      );
    else url_ += 'digitalCode=' + encodeURIComponent('' + digitalCode) + '&';
    if (quantity === undefined || quantity === null)
      throw new Error(
        "The parameter 'quantity' must be defined and cannot be null."
      );
    else url_ += 'quantity=' + encodeURIComponent('' + quantity) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processRedeemCode(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processRedeemCode(<any>response_);
            } catch (e) {
              return <Observable<IOrderResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IOrderResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processRedeemCode(
    response: HttpResponseBase
  ): Observable<IOrderResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IOrderResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IOrderResponse>(<any>null);
  }

  updateOrderTemplate(orderTemplateRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/UpdateOrderTemplate?';
    if (
      orderTemplateRequestJObject === undefined ||
      orderTemplateRequestJObject === null
    )
      throw new Error(
        "The parameter 'orderTemplateRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateRequestJObject=' +
        encodeURIComponent('' + orderTemplateRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateOrderTemplate(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateOrderTemplate(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateOrderTemplate(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  updateOrderTemplateCollection(
    orderTemplateCollectionRequestJObject: any
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/OrderManagement/UpdateOrderTemplateCollection?';
    if (
      orderTemplateCollectionRequestJObject === undefined ||
      orderTemplateCollectionRequestJObject === null
    )
      throw new Error(
        "The parameter 'orderTemplateCollectionRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'orderTemplateCollectionRequestJObject=' +
        encodeURIComponent('' + orderTemplateCollectionRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUpdateOrderTemplateCollection(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUpdateOrderTemplateCollection(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUpdateOrderTemplateCollection(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  extractDocument(documentExtractRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/ExtractDocument?';
    if (
      documentExtractRequestJObject === undefined ||
      documentExtractRequestJObject === null
    )
      throw new Error(
        "The parameter 'documentExtractRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'documentExtractRequestJObject=' +
        encodeURIComponent('' + documentExtractRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processExtractDocument(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processExtractDocument(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processExtractDocument(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  analyzeDocument(documentRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/AnalyzeDocument?';
    if (documentRequestJObject === undefined || documentRequestJObject === null)
      throw new Error(
        "The parameter 'documentRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'documentRequestJObject=' +
        encodeURIComponent('' + documentRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processAnalyzeDocument(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processAnalyzeDocument(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processAnalyzeDocument(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  uploadDocument(documentUploadRequestJObject: any): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/UploadDocument?';
    if (
      documentUploadRequestJObject === undefined ||
      documentUploadRequestJObject === null
    )
      throw new Error(
        "The parameter 'documentUploadRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'documentUploadRequestJObject=' +
        encodeURIComponent('' + documentUploadRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadDocument(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadDocument(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUploadDocument(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  uploadDeliveryNotePdf(
    orderNumber: string,
    postingAccountId: number
  ): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/OrderManagement/UploadDeliveryNotePdf?';
    if (orderNumber === undefined || orderNumber === null)
      throw new Error(
        "The parameter 'orderNumber' must be defined and cannot be null."
      );
    else url_ += 'orderNumber=' + encodeURIComponent('' + orderNumber) + '&';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processUploadDeliveryNotePdf(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processUploadDeliveryNotePdf(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processUploadDeliveryNotePdf(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }
}

@Injectable({
  providedIn: 'root',
})
export class PostingAccountApiService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver:
    | ((key: string, value: any) => any)
    | undefined = undefined;

  constructor(
    @Inject(HttpClient) http: HttpClient,
    @Optional() @Inject(API_BASE_URL) baseUrl?: string
  ) {
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : '';
  }

  createOnlineAccountingRecord(
    postingAccountOperationRequestJObject: any
  ): Observable<IResponse> {
    let url_ =
      this.baseUrl + '/api/PostingAccount/CreateOnlineAccountingRecord?';
    if (
      postingAccountOperationRequestJObject === undefined ||
      postingAccountOperationRequestJObject === null
    )
      throw new Error(
        "The parameter 'postingAccountOperationRequestJObject' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountOperationRequestJObject=' +
        encodeURIComponent('' + postingAccountOperationRequestJObject) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreateOnlineAccountingRecord(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreateOnlineAccountingRecord(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreateOnlineAccountingRecord(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  createPostingAccountSyncProtocol(
    postingAccountNumber: string,
    syncOperationId: number,
    autoUpdate: boolean
  ): Observable<void> {
    let url_ =
      this.baseUrl + '/api/PostingAccount/CreatePostingAccountSyncProtocol?';
    if (postingAccountNumber === undefined || postingAccountNumber === null)
      throw new Error(
        "The parameter 'postingAccountNumber' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountNumber=' +
        encodeURIComponent('' + postingAccountNumber) +
        '&';
    if (syncOperationId === undefined || syncOperationId === null)
      throw new Error(
        "The parameter 'syncOperationId' must be defined and cannot be null."
      );
    else
      url_ +=
        'syncOperationId=' + encodeURIComponent('' + syncOperationId) + '&';
    if (autoUpdate === undefined || autoUpdate === null)
      throw new Error(
        "The parameter 'autoUpdate' must be defined and cannot be null."
      );
    else url_ += 'autoUpdate=' + encodeURIComponent('' + autoUpdate) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processCreatePostingAccountSyncProtocol(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processCreatePostingAccountSyncProtocol(
                <any>response_
              );
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processCreatePostingAccountSyncProtocol(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  deletePostingAccountSyncProtocol(
    postingAccountSyncProtocolId: number
  ): Observable<void> {
    let url_ =
      this.baseUrl + '/api/PostingAccount/DeletePostingAccountSyncProtocol?';
    if (
      postingAccountSyncProtocolId === undefined ||
      postingAccountSyncProtocolId === null
    )
      throw new Error(
        "The parameter 'postingAccountSyncProtocolId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountSyncProtocolId=' +
        encodeURIComponent('' + postingAccountSyncProtocolId) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({}),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processDeletePostingAccountSyncProtocol(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processDeletePostingAccountSyncProtocol(
                <any>response_
              );
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processDeletePostingAccountSyncProtocol(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }

  getPostingAccountBalances(): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/PostingAccount/GetPostingAccountBalances';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPostingAccountBalances(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPostingAccountBalances(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetPostingAccountBalances(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getPostingAccountsWithBalances(): Observable<
    IPostingAccountsWithBalancesResponse
  > {
    let url_ =
      this.baseUrl + '/api/PostingAccount/GetPostingAccountsWithBalances';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPostingAccountsWithBalances(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPostingAccountsWithBalances(<any>response_);
            } catch (e) {
              return <Observable<IPostingAccountsWithBalancesResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IPostingAccountsWithBalancesResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPostingAccountsWithBalances(
    response: HttpResponseBase
  ): Observable<IPostingAccountsWithBalancesResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IPostingAccountsWithBalancesResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IPostingAccountsWithBalancesResponse>(<any>null);
  }

  getAccountingRecords(
    postingAccountNumber: string,
    accountingRecordRangeStart: number
  ): Observable<IAccountingRecordResponse> {
    let url_ = this.baseUrl + '/api/PostingAccount/GetAccountingRecords?';
    if (postingAccountNumber === undefined || postingAccountNumber === null)
      throw new Error(
        "The parameter 'postingAccountNumber' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountNumber=' +
        encodeURIComponent('' + postingAccountNumber) +
        '&';
    if (
      accountingRecordRangeStart === undefined ||
      accountingRecordRangeStart === null
    )
      throw new Error(
        "The parameter 'accountingRecordRangeStart' must be defined and cannot be null."
      );
    else
      url_ +=
        'accountingRecordRangeStart=' +
        encodeURIComponent('' + accountingRecordRangeStart) +
        '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAccountingRecords(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAccountingRecords(<any>response_);
            } catch (e) {
              return <Observable<IAccountingRecordResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IAccountingRecordResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAccountingRecords(
    response: HttpResponseBase
  ): Observable<IAccountingRecordResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IAccountingRecordResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IAccountingRecordResponse>(<any>null);
  }

  searchAccountingRecords(
    accountingRecordSearchRequest: AccountingRecordSearchRequest
  ): Observable<IAccountingRecordResponse> {
    let url_ = this.baseUrl + '/api/PostingAccount/SearchAccountingRecords';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(accountingRecordSearchRequest);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSearchAccountingRecords(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSearchAccountingRecords(<any>response_);
            } catch (e) {
              return <Observable<IAccountingRecordResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IAccountingRecordResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processSearchAccountingRecords(
    response: HttpResponseBase
  ): Observable<IAccountingRecordResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IAccountingRecordResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IAccountingRecordResponse>(<any>null);
  }

  getAccountingRecordFormData(
    postingAccountId: number
  ): Observable<IAccountingRecordFormDataResponse> {
    let url_ =
      this.baseUrl + '/api/PostingAccount/GetAccountingRecordFormData?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAccountingRecordFormData(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAccountingRecordFormData(<any>response_);
            } catch (e) {
              return <Observable<IAccountingRecordFormDataResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IAccountingRecordFormDataResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAccountingRecordFormData(
    response: HttpResponseBase
  ): Observable<IAccountingRecordFormDataResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IAccountingRecordFormDataResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IAccountingRecordFormDataResponse>(<any>null);
  }

  getAccountingRecordsByBalanceType(
    postingAccountId: number,
    articleId: number,
    balanceTypeId: number,
    qualityTypeId: number
  ): Observable<IAccountingRecordResponse> {
    let url_ =
      this.baseUrl + '/api/PostingAccount/GetAccountingRecordsByBalanceType?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (articleId === undefined || articleId === null)
      throw new Error(
        "The parameter 'articleId' must be defined and cannot be null."
      );
    else url_ += 'articleId=' + encodeURIComponent('' + articleId) + '&';
    if (balanceTypeId === undefined || balanceTypeId === null)
      throw new Error(
        "The parameter 'balanceTypeId' must be defined and cannot be null."
      );
    else
      url_ += 'balanceTypeId=' + encodeURIComponent('' + balanceTypeId) + '&';
    if (qualityTypeId === undefined || qualityTypeId === null)
      throw new Error(
        "The parameter 'qualityTypeId' must be defined and cannot be null."
      );
    else
      url_ += 'qualityTypeId=' + encodeURIComponent('' + qualityTypeId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetAccountingRecordsByBalanceType(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetAccountingRecordsByBalanceType(
                <any>response_
              );
            } catch (e) {
              return <Observable<IAccountingRecordResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IAccountingRecordResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetAccountingRecordsByBalanceType(
    response: HttpResponseBase
  ): Observable<IAccountingRecordResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IAccountingRecordResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IAccountingRecordResponse>(<any>null);
  }

  getPostingAccount(
    postingAccountId: number,
    articleId: number
  ): Observable<IPostingAccountResponse> {
    let url_ = this.baseUrl + '/api/PostingAccount/GetPostingAccount?';
    if (postingAccountId === undefined || postingAccountId === null)
      throw new Error(
        "The parameter 'postingAccountId' must be defined and cannot be null."
      );
    else
      url_ +=
        'postingAccountId=' + encodeURIComponent('' + postingAccountId) + '&';
    if (articleId === undefined || articleId === null)
      throw new Error(
        "The parameter 'articleId' must be defined and cannot be null."
      );
    else url_ += 'articleId=' + encodeURIComponent('' + articleId) + '&';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPostingAccount(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPostingAccount(<any>response_);
            } catch (e) {
              return <Observable<IPostingAccountResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IPostingAccountResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPostingAccount(
    response: HttpResponseBase
  ): Observable<IPostingAccountResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IPostingAccountResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IPostingAccountResponse>(<any>null);
  }

  getPostingAccounts(): Observable<IPostingAccountResponse> {
    let url_ = this.baseUrl + '/api/PostingAccount/GetPostingAccounts';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPostingAccounts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPostingAccounts(<any>response_);
            } catch (e) {
              return <Observable<IPostingAccountResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IPostingAccountResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPostingAccounts(
    response: HttpResponseBase
  ): Observable<IPostingAccountResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IPostingAccountResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IPostingAccountResponse>(<any>null);
  }

  getOnlinePostingAccounts(): Observable<IResponse> {
    let url_ = this.baseUrl + '/api/PostingAccount/GetOnlinePostingAccounts';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetOnlinePostingAccounts(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetOnlinePostingAccounts(<any>response_);
            } catch (e) {
              return <Observable<IResponse>>(<any>_observableThrow(e));
            }
          } else
            return <Observable<IResponse>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processGetOnlinePostingAccounts(
    response: HttpResponseBase
  ): Observable<IResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IResponse>JSON.parse(_responseText, this.jsonParseReviver);
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IResponse>(<any>null);
  }

  getPostingAccountsSummaries(): Observable<IPostingAccountResponse> {
    let url_ = this.baseUrl + '/api/PostingAccount/GetPostingAccountsSummaries';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPostingAccountsSummaries(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPostingAccountsSummaries(<any>response_);
            } catch (e) {
              return <Observable<IPostingAccountResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IPostingAccountResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPostingAccountsSummaries(
    response: HttpResponseBase
  ): Observable<IPostingAccountResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IPostingAccountResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IPostingAccountResponse>(<any>null);
  }

  getPostingAccountSyncProtocols(): Observable<
    IPostingAccountSyncProtocolResponse
  > {
    let url_ =
      this.baseUrl + '/api/PostingAccount/GetPostingAccountSyncProtocols';
    url_ = url_.replace(/[?&]$/, '');

    let options_: any = {
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        Accept: 'application/json',
      }),
    };

    return this.http
      .request('get', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processGetPostingAccountSyncProtocols(response_);
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processGetPostingAccountSyncProtocols(<any>response_);
            } catch (e) {
              return <Observable<IPostingAccountSyncProtocolResponse>>(
                (<any>_observableThrow(e))
              );
            }
          } else
            return <Observable<IPostingAccountSyncProtocolResponse>>(
              (<any>_observableThrow(response_))
            );
        })
      );
  }

  protected processGetPostingAccountSyncProtocols(
    response: HttpResponseBase
  ): Observable<IPostingAccountSyncProtocolResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 200) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          let result200: any = null;
          result200 =
            _responseText === ''
              ? null
              : <IPostingAccountSyncProtocolResponse>(
                  JSON.parse(_responseText, this.jsonParseReviver)
                );
          return _observableOf(result200);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<IPostingAccountSyncProtocolResponse>(<any>null);
  }

  savePostingAccountSyncProtocolDtoChanges(
    postingAccountSyncProtocolDto: PostingAccountSyncProtocolDto
  ): Observable<void> {
    let url_ =
      this.baseUrl +
      '/api/PostingAccount/SavePostingAccountSyncProtocolDtoChanges';
    url_ = url_.replace(/[?&]$/, '');

    const content_ = JSON.stringify(postingAccountSyncProtocolDto);

    let options_: any = {
      body: content_,
      observe: 'response',
      responseType: 'blob',
      headers: new HttpHeaders({
        'Content-Type': 'application/json',
      }),
    };

    return this.http
      .request('post', url_, options_)
      .pipe(
        _observableMergeMap((response_: any) => {
          return this.processSavePostingAccountSyncProtocolDtoChanges(
            response_
          );
        })
      )
      .pipe(
        _observableCatch((response_: any) => {
          if (response_ instanceof HttpResponseBase) {
            try {
              return this.processSavePostingAccountSyncProtocolDtoChanges(
                <any>response_
              );
            } catch (e) {
              return <Observable<void>>(<any>_observableThrow(e));
            }
          } else return <Observable<void>>(<any>_observableThrow(response_));
        })
      );
  }

  protected processSavePostingAccountSyncProtocolDtoChanges(
    response: HttpResponseBase
  ): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse
        ? response.body
        : (<any>response).error instanceof Blob
        ? (<any>response).error
        : undefined;

    let _headers: any = {};
    if (response.headers) {
      for (let key of response.headers.keys()) {
        _headers[key] = response.headers.get(key);
      }
    }
    if (status === 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return _observableOf<void>(<any>null);
        })
      );
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(
        _observableMergeMap((_responseText) => {
          return throwException(
            'An unexpected server error occurred.',
            status,
            _responseText,
            _headers
          );
        })
      );
    }
    return _observableOf<void>(<any>null);
  }
}

export interface IAddressSearchResponse {
  addresses?: IAddressSearchDto[];
}

export interface IAddressSearchDto {
  AddressId?: number;
  AddressNumber?: string;
  Street?: string;
  StreetNumber?: string;
  PostalCode?: string;
  City?: string;
  CompanyName?: string;
  Country?: string;
  Lat?: number;
  Lng?: number;
  Distance?: number;
  PickupPalletAvailabilities?: IPalletAvailabilityDto[];
  SupportedDropoffPallets?: IPalletDto[];
  FromTime?: Date | null;
  ToTime?: Date | null;
  Active?: boolean;
  BusinessHours?: IBusinessHoursDto[];
}

export interface IPalletAvailabilityDto {
  PalletId?: number;
  Amount?: number;
}

export interface IPalletDto {
  PalletId?: number;
  PalletName?: string;
}

export interface IBusinessHoursDto {
  BusinessHoursId?: number;
  AddressId?: number;
  DayOfWeek?: number;
  FromTime?: Date;
  ToTime?: Date;
  Active?: boolean;
}

export interface AddressSearchRequest {
  ContractId?: number;
  Type?: LocationType;
  Lat?: number;
  Lng?: number;
  Radius?: number;
  PalletId?: number;
  Amount?: number;
  PostingAccountId?: number;
  Upn?: string;
  DaysOfWeek?: number[];
}

export enum LocationType {
  Pickup = 0,
  Delivery = 1,
  Both = 2,
}

export interface IResponse {
  ValidationErrorDtos?: IValidationErrorDto[];
  WarningDtos?: IWarningDto[];
}

export interface IValidationErrorDto {
  ErrorMessage?: string;
}

export interface IWarningDto {
  WarningMessage?: string;
}

export interface IOrderResponse {
  AddressDtos?: IAddressDto[];
  OrderConditionDtos?: IOrderConditionDto[];
  OrderDtos?: IOrderDto[];
  OrderProposalDtos?: IOrderDto[];
  OrderTemplateCollectionDtos?: IOrderTemplateCollectionDto[];
  PalletDtos?: IPalletDto[];
  PostingAccountDisplayName?: string;
  PostingAccountDtos?: IPostingAccountDto[];
  PostingAccountOrdersStatisticDto?: IPostingAccountOrdersStatisticDto;
  UserOrderPermissionDto?: IUserOrderPermissionDto;
}

export interface IAddressDto {
  Active?: boolean;
  AddressId?: number;
  AddressNumber?: string;
  BoxTruck?: boolean | null;
  ChangeDate?: Date | null;
  ChangeUser?: string;
  City?: string;
  CompanyName?: string;
  Country?: string;
  CreateDate?: Date;
  CreateUser?: string;
  DischargCourt?: boolean | null;
  DischargRamp?: boolean | null;
  DischargRampMaxHeight?: number | null;
  DischargRampMinHeight?: number | null;
  FromTime?: Date | null;
  Guid?: string;
  JumboTruck?: boolean | null;
  LongitudinalLoading?: boolean | null;
  PostalCode?: string;
  PostingAccountId?: number;
  Remark?: string;
  Street?: string;
  StreetNumber?: string;
  ToTime?: Date | null;
  TrailerTruck?: boolean | null;
  TransverseLoading?: boolean | null;
}

export interface IOrderConditionDto {
  DayOfWeek?: number;
  PalletId?: number;
  PreferredDateDayIntervalMax?: number;
  PreferredDateDayIntervalMin?: number;
  PreferredFixedDateAllowed?: boolean;
}

export interface IOrderDto {
  AddressId?: number;
  AnnouncementRequired?: boolean;
  AnnouncementMailingList?: string;
  CancelDate?: Date | null;
  CancellationRequestDate?: Date | null;
  CancellationRequestUser?: string;
  CancelUser?: string;
  ChangeDate?: Date | null;
  ChangeUser?: string;
  City?: string;
  Comment?: string;
  CompanyName?: string;
  Country?: string;
  CreateDate?: Date;
  CreateUser?: string;
  CurrentProposedExecutionDate?: Date | null;
  CurrentProposedPalletName?: string;
  CurrentProposedPlace?: string;
  CurrentProposedToDate?: Date | null;
  DeliveryNoteNumber?: string;
  DeliveryNotePdfAvailable?: boolean;
  ExecutionDate?: Date | null;
  ExecutionPeriodBegin?: Date;
  ExecutionPeriodEnd?: Date;
  ExternalReference?: string;
  GrantDate?: Date | null;
  GrantUser?: string;
  Guid?: string;
  IndoorStored?: boolean;
  OrderContractType?: string;
  OrderId?: number;
  OrderNumber?: string;
  OrderProposalAccepted?: boolean;
  OrderProposalAvailable?: boolean;
  OrderProposalStatusId?: number | null;
  OrderProposalStatusName?: any;
  OrderStatusId?: number;
  OrderStatusName?: string;
  OrderTypeId?: number;
  PalletId?: number;
  PalletName?: string;
  AricleName?: string;
  QualityName?: string;
  ParentOrderId?: number | null;
  PostalCode?: string;
  PostingAccountId?: number;
  PostingAccountNumber?: string;
  PreferredPlace?: string;
  PreferredTime?: string;
  RowVersion?: string;
  Street?: string;
  StreetNumber?: string;
  Quantity?: number;
  DigitalCode?: string;
}

export interface IOrderTemplateCollectionDto {
  ChangeDate?: Date | null;
  ChangeUser?: string;
  Comment?: string;
  CreateDate?: Date;
  CreateUser?: string;
  Guid?: string;
  OrderTemplateCollectionId?: number;
  OrderTypeId?: number;
  OrderTypeName?: string;
  PostingAccountDisplayName?: string;
  PostingAccountId?: number;
  TemplateCollectionName?: string;
}

export interface IPostingAccountDto {
  PostingAccountId?: number;
  AccountNumber?: string;
  Articles?: string[];
  PostingAccountDisplayName?: string;
  NeedCoordination?: boolean;
}

export interface IPostingAccountOrdersStatisticDto {
  NumberOfGrantedOrders?: number;
  NumberOfOrdersInCoordination?: number;
  NumberOfOrdersInProgress?: number;
  NumberOfRegisteredOrders?: number;
  PostingAccountDisplayName?: string;
  PostingAccountId?: number;
  PostingAccountNumber?: string;
}

export interface IUserOrderPermissionDto {
  CanCancelOrder?: boolean;
  CanCreateOrder?: boolean;
  CanDeleteOrder?: boolean;
  CanEditOrder?: boolean;
  CanGrantOrder?: boolean;
}

export interface IFormDataResponse {
  AddressDtos?: IAddressDto[];
  OrderConditionDtos?: IOrderConditionDto[];
  OrderTypeId?: number;
  PalletDtos?: IPalletDto[];
  OrderContractDtos?: IOrderContractDto[];
}

export interface IOrderContractDto {
  Description?: string;
  OrderContractType?: string;
}

export interface IPostingAccountsWithBalancesResponse {
  PostingAccountsWithBalances?: IPostingAccountsBalanceDto[];
}

export interface IPostingAccountsBalanceDto {
  PostingAccountId?: number;
  PostingAccountDisplayName?: string;
  PostingAccountNumber?: string;
  Inactive?: boolean;
  IsPoolingAccount?: boolean;
  PalletsForPickup?: IAvailablePalletsDto[];
  PalletsForDropoff?: IAvailablePalletsDto[];
  Balances?: IBalancesDto[];
}

export interface IAvailablePalletsDto {
  PalletId?: number;
  ArticleId?: number;
  ArticleName?: string;
  QualityName?: string;
}

export interface IBalancesDto {
  ArticleId?: number;
  QualityTypeId?: number;
  QualityTypeName?: string;
  CoordinatedBalance?: number;
  ProvisionalBalance?: number;
  ProvisionalCharge?: number;
  ProvisionalCredit?: number;
  UncoordinatedCharge?: number;
  UncoordinatedCredit?: number;
}

export interface IAccountingRecordResponse {
  AccountingRecordDtos?: AccountingRecordDto[];
  PostingAccountDto?: PostingAccountDto;
}

export interface AccountingRecordDto {
  ProcessId?: number;
  AccountingRecordId?: number;
  AccountingRecordDate?: Date;
  AccountingRecordTyp?: string;
  AccountingRecordTypDescription?: string;
  AccountingRecordStateTypId?: number;
  Article?: string;
  ReferenceNumber?: string;
  ExtDescription?: string;
  Quality?: string;
  Charge?: number;
  Credit?: number;
}

export interface PostingAccountDto {
  PostingAccountId?: number;
  AccountNumber?: string;
  Articles?: string[];
  PostingAccountDisplayName?: string;
  NeedCoordination?: boolean;
}

export interface AccountingRecordSearchRequest {
  AccountingRecordDateFrom?: Date | null;
  AccountingRecordDateTo?: Date | null;
  AccountingRecordStateTypeId?: number;
  AccountingRecordTypeId?: number;
  ArticleId?: number;
  ExtDescription?: string;
  PostingAccountId?: number;
  QualityId?: number;
  QuantityFrom?: number;
  QuantityTo?: number;
  ReferenceNumber?: string;
  Upn?: string;
}

export interface IAccountingRecordFormDataResponse {
  AccountingRecordStateTypeDtos?: IAccountingRecordStateTypeDto[];
  AccountingRecordTypeDtos?: IAccountingRecordTypeDto[];
  ArticleDtos?: IArticleDto[];
  QualityDtos?: IQualityDto[];
}

export interface IAccountingRecordStateTypeDto {
  AccountingRecordStateTypeId?: number;
  AccountingRecordStateTypeName?: string;
}

export interface IAccountingRecordTypeDto {
  AccountingRecordTypeId?: number;
  AccountingRecordTypeName?: string;
}

export interface IArticleDto {
  ArticleId?: number;
  ArticleName?: string;
}

export interface IQualityDto {
  QualityId?: number;
  QualityName?: string;
}

export interface IPostingAccountResponse {
  AccountingRecordDtos?: AccountingRecordDto[];
  PostingAccountBalanceDtos?: PostingAccountBalanceDto[];
  PostingAccountDtos?: PostingAccountDto[];
  PostingAccountSummaryDtos?: PostingAccountSummaryDto[];
  UserPermissionDto?: UserPermissionDto;
}

export interface PostingAccountBalanceDto {
  ArticleId?: number;
  ArticleName?: string;
  CoordinatedBalance?: number;
  ProvisionalBalance?: number;
  ProvisionalCharge?: number;
  ProvisionalCredit?: number;
  QualityTypeId?: number;
  QualityTypeName?: string;
  UncoordinatedCharge?: number;
  UncoordinatedCredit?: number;
}

export interface PostingAccountSummaryDto {
  ArticleId?: number;
  ArticleName?: string;
  NeedCoordination?: boolean;
  NumberAccountingRecords?: number;
  OldestUncoordinatedChargeAge?: number;
  OldestUncoordinatedCreditAge?: number;
  PostingAccountDisplayName?: string;
  PostingAccountId?: number;
  PostingAccountNumber?: string;
}

export interface UserPermissionDto {
  PostingAccountDisplayName?: string;
}

export interface IPostingAccountSyncProtocolResponse {
  PostingAccountSyncProtocolDtos?: PostingAccountSyncProtocolDto[];
  SyncOperationDtos?: SyncOperationDto[];
}

export interface PostingAccountSyncProtocolDto {
  PostingAccountSyncProtocolId?: number;
  CreateDate?: Date | null;
  ChangeDate?: Date | null;
  CreateUser?: string;
  ChangeUser?: string;
  PostingAccountNumber?: string;
  SyncOperationId?: number;
  SyncRequestDate?: Date | null;
  SyncResponseDate?: Date | null;
  StartSyncDate?: Date | null;
  EndSyncDate?: Date | null;
  SyncToDate?: Date | null;
  LastSyncDate?: Date | null;
  SyncSessionId?: string;
  SyncFailedWithErrorCode?: number | null;
  SuccessedAccountingRecords?: string;
  SyncResponseUrl?: string;
  SyncResponseStateUrl?: string;
  IsLocked?: boolean;
  AutoUpdate?: boolean;
  SyncOperation?: string;
}

export interface SyncOperationDto {
  SyncOperationId?: number;
  SyncOperationDescription?: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): Observable<any> {
  if (result !== null && result !== undefined) return _observableThrow(result);
  else
    return _observableThrow(
      new ApiException(message, status, response, headers, null)
    );
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next('');
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = (event) => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
